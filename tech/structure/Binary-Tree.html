<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Binary-Tree | Hello!</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/favicon.ico">
    <meta name="description" content="everything about me">
    
    <link rel="preload" href="/assets/css/0.styles.9f84806b.css" as="style"><link rel="preload" href="/assets/js/app.fd63b75d.js" as="script"><link rel="preload" href="/assets/js/2.fc10bb63.js" as="script"><link rel="preload" href="/assets/js/1.13179e0f.js" as="script"><link rel="preload" href="/assets/js/11.1eb29c58.js" as="script"><link rel="prefetch" href="/assets/js/10.0cd7dbe0.js"><link rel="prefetch" href="/assets/js/12.65fb22c1.js"><link rel="prefetch" href="/assets/js/13.cedf35ff.js"><link rel="prefetch" href="/assets/js/14.3854cc93.js"><link rel="prefetch" href="/assets/js/15.f713e7c7.js"><link rel="prefetch" href="/assets/js/16.b5fe0e8f.js"><link rel="prefetch" href="/assets/js/17.0d4ddd08.js"><link rel="prefetch" href="/assets/js/18.e4c546ac.js"><link rel="prefetch" href="/assets/js/19.58e19a77.js"><link rel="prefetch" href="/assets/js/20.b4ee4d17.js"><link rel="prefetch" href="/assets/js/21.ce06095b.js"><link rel="prefetch" href="/assets/js/22.7a364f9d.js"><link rel="prefetch" href="/assets/js/23.051947cd.js"><link rel="prefetch" href="/assets/js/24.b7e6255c.js"><link rel="prefetch" href="/assets/js/25.17c83a3f.js"><link rel="prefetch" href="/assets/js/26.9a1735a4.js"><link rel="prefetch" href="/assets/js/27.4dacb916.js"><link rel="prefetch" href="/assets/js/28.65fc86fa.js"><link rel="prefetch" href="/assets/js/29.1291eacf.js"><link rel="prefetch" href="/assets/js/3.6972e55e.js"><link rel="prefetch" href="/assets/js/30.467c251a.js"><link rel="prefetch" href="/assets/js/31.f99f66c6.js"><link rel="prefetch" href="/assets/js/32.33ffd332.js"><link rel="prefetch" href="/assets/js/33.3e40659a.js"><link rel="prefetch" href="/assets/js/34.30ffbcbc.js"><link rel="prefetch" href="/assets/js/35.0ea846ce.js"><link rel="prefetch" href="/assets/js/36.6189fe91.js"><link rel="prefetch" href="/assets/js/37.f4b2bc76.js"><link rel="prefetch" href="/assets/js/4.b9dfc920.js"><link rel="prefetch" href="/assets/js/5.b584516e.js"><link rel="prefetch" href="/assets/js/6.17d2031e.js"><link rel="prefetch" href="/assets/js/7.3d31218e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b562965b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9f84806b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hello!</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/resume/aboutme.html" class="nav-link">
  AboutMe
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Contact" class="dropdown-title"><span class="title">Contact</span> <span class="arrow down"></span></button> <button type="button" aria-label="Contact" class="mobile-dropdown-title"><span class="title">Contact</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Asacea" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="mailto:imzhangqianyu@outlook.com" class="nav-link external">
  Email
  <!----></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/resume/aboutme.html" class="nav-link">
  AboutMe
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Contact" class="dropdown-title"><span class="title">Contact</span> <span class="arrow down"></span></button> <button type="button" aria-label="Contact" class="mobile-dropdown-title"><span class="title">Contact</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Asacea" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="mailto:imzhangqianyu@outlook.com" class="nav-link external">
  Email
  <!----></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">Home</a></li><li><section class="sidebar-group depth-0"><a href="/tech/tech" class="sidebar-heading clickable open"><span>Technique</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/tech/structure/Array-Table" class="sidebar-heading clickable open"><span>Data Structure</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/structure/Array-Table.html" class="sidebar-link">Array-Table</a></li><li><a href="/tech/structure/String.html" class="sidebar-link">String</a></li><li><a href="/tech/structure/LinearList.html" class="sidebar-link">LinearList</a></li><li><a href="/tech/structure/Stack-Queue.html" class="sidebar-link">Stack-Queue</a></li><li><a href="/tech/structure/Binary-Tree.html" aria-current="page" class="active sidebar-link">Binary-Tree</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/structure/Binary-Tree.html#树的定义" class="sidebar-link">树的定义</a></li><li class="sidebar-sub-header"><a href="/tech/structure/Binary-Tree.html#二叉树" class="sidebar-link">二叉树</a></li><li class="sidebar-sub-header"><a href="/tech/structure/Binary-Tree.html#二叉树的遍历" class="sidebar-link">二叉树的遍历</a></li><li class="sidebar-sub-header"><a href="/tech/structure/Binary-Tree.html#线索二叉树-略" class="sidebar-link">线索二叉树（略</a></li><li class="sidebar-sub-header"><a href="/tech/structure/Binary-Tree.html#树、森林和二叉树的关系" class="sidebar-link">树、森林和二叉树的关系</a></li><li class="sidebar-sub-header"><a href="/tech/structure/Binary-Tree.html#哈夫曼树及其应用" class="sidebar-link">哈夫曼树及其应用</a></li></ul></li><li><a href="/tech/structure/Graph.html" class="sidebar-link">Graph</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/tech/alg/Basic-Algorithms" class="sidebar-heading clickable"><span>Algorithm</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/alg/Basic-Algorithms.html" class="sidebar-link">Basic-Algorithms</a></li><li><a href="/tech/alg/Sort.html" class="sidebar-link">Sort</a></li><li><a href="/tech/alg/Search.html" class="sidebar-link">Search</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/travel/note" class="sidebar-heading clickable"><span>Travel Journal</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/travel/Vancouver.html" class="sidebar-link">Vancouver</a></li><li><a href="/travel/emeishan.html" class="sidebar-link">峨眉山</a></li></ul></section></li><li><a href="/resume/aboutme.html" class="sidebar-link">Everything about me</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="树与二叉树"><a href="#树与二叉树" class="header-anchor">#</a> 树与二叉树</h1> <h2 id="树的定义"><a href="#树的定义" class="header-anchor">#</a> 树的定义</h2> <ol><li><p>关系：一对多，层次化</p></li> <li><p>基本概念：</p> <ul><li>根：没有前驱，有一个或者多个后继</li> <li>子树：只有一个前驱，有一个或者多个后继，子树之间互不相交</li> <li>结点的度：一个结点的子树个数    ； 树的度：树中所有结点的度的最大值</li> <li>结点的层次：从根结点开始定义，根的层次为1 ，它的直接后继的层次为2，依次类推</li> <li>树的高度（深度）：层次的最大值</li> <li>结点的层序编号：将树中的结点按从上层到下层、同层从左到右的次序排成一个线性序列，依次给它们编以连续的自然数</li> <li>结点之间的层次关系：
<ul><li>双亲结点：结点的直接前驱</li> <li>前辈,后辈：比较结点的层次</li></ul></li></ul></li> <li><p>树的数据类型</p></li></ol> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <ol><li><p>定义：</p> <ul><li>每个结点的度都不大于2；</li> <li>每个结点的孩子结点次序都不能任意颠倒（左子树和右子树）</li></ul></li> <li><p>性质：</p> <ol><li><p>在二叉树的第i层上至多有2^(i-1)个结点</p></li> <li><p>深度为k的二叉树至多有2^k-1个结点</p></li> <li><p>任意一棵二叉树T，若终端节点(度数为0的结点)数为m，而其度数为2的节点数为n，则m=n+1;</p></li> <li><p>满二叉树：深度为k且有2^k-1个结点的二叉树</p></li> <li><p>完全二叉树：深度为k，结点数为n，结点位置序号与相同高度的满二叉树一一对应</p> <p><img src="/assets/img/17.5478ace7.jpg" alt="An image"></p></li> <li><p>具有n个结点的完全二叉树的深度为(log2 n)+1</p></li></ol></li> <li><p>存储结构：</p> <ul><li><p>顺序存储</p></li> <li><p>链式存储：</p> <p><img src="/assets/img/18.89c7eb10.png" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>
    DataType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> LChild<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> RChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ol> <h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="header-anchor">#</a> 二叉树的遍历</h2> <ol><li><p>遍历（左右孩子和根的访问顺序）</p> <ul><li><p>先序遍历</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//Data-&gt;L-&gt;R</span>
<span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>中序遍历</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//L-&gt;Data-&gt;R</span>
<span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>后序遍历</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//L-&gt;R-&gt;Data</span>
<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">PostOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PostOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>遍历算法的应用</p> <ul><li><p>输出二叉树当中的叶子结点</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>统计叶子结点的数目</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//方法一：递归遍历统计</span>
<span class="token keyword">int</span> LeafCount<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">//全局变量，用于统计叶子结点的数目</span>
<span class="token keyword">void</span> <span class="token function">leaf</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
            LeafCount<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//方法二：分治算法</span>
<span class="token keyword">int</span> <span class="token function">leaf</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> LeafCnt<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//空树</span>
        LeafCnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//叶子结点</span>
        LeafCnt<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        LeafCnt<span class="token operator">=</span><span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">leaf</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> LeafCnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>建立二叉链表方式存储的二叉树</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>bi<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//这里传的是二级指针</span>
   <span class="token comment">//假设data的类型是字符型</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">'.'</span><span class="token punctuation">)</span>
        <span class="token operator">*</span>bi<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token operator">*</span>bi<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>bi<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>bi<span class="token punctuation">)</span><span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>bi<span class="token punctuation">)</span><span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>求二叉树的高度</p> <p>逻辑 ：高度就是二叉树的层次的最大值，或者说左右子树的高度最大值+1</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//分沿法</span>
<span class="token keyword">int</span> <span class="token function">PostTreeDepth</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> hl<span class="token punctuation">,</span>hr<span class="token punctuation">,</span>max<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        hl<span class="token operator">=</span><span class="token function">PostTreeDepth</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hr<span class="token operator">=</span><span class="token function">PostTreeDepth</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        max<span class="token operator">=</span>hl<span class="token operator">&gt;</span>hr<span class="token operator">?</span>hl<span class="token operator">:</span>hr<span class="token punctuation">;</span>
        <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//先序遍历</span>
<span class="token keyword">int</span> depht<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//全局变量</span>
<span class="token keyword">void</span> <span class="token function">PreTreeDepth</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">,</span><span class="token keyword">int</span> h<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>h<span class="token operator">&gt;</span>depth<span class="token punctuation">)</span>
            depht<span class="token operator">=</span>h<span class="token punctuation">;</span>
        <span class="token function">PreTreeDepth</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>LChild<span class="token punctuation">,</span>h<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PreTreeDepth</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>RChild<span class="token punctuation">,</span>h<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>按横向树形显示二叉树<img src="/assets/img/19.2d90bff3.jpg" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">PrintTree</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">,</span><span class="token keyword">int</span> nLayer<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//实现先右后左</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nLayer<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%c\n&quot;</span><span class="token punctuation">,</span>bt<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintTree</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>RChild<span class="token punctuation">,</span>nLayer<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PrintTree</span><span class="token punctuation">(</span>bt<span class="token operator">-&gt;</span>LChild<span class="token punctuation">,</span>nlayer<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>层次遍历法(<strong>略</strong>)</p> <p><img src="/assets/img/20.6371f94b.png" alt="An image"></p> <p><img src="/assets/img/21.d09f4e76.png" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree bt<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiTree Queue<span class="token punctuation">[</span>MAXNODE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//定义队列，队列先进先出</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span>rear<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token comment">//空树</span>
        <span class="token keyword">return</span> <span class="token punctuation">;</span>
    front<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    Queue<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>bt<span class="token punctuation">;</span>  <span class="token comment">//根结点入队列</span>
    rear<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>rear<span class="token operator">!=</span>front<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//队列不空，继续遍历</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>Queue<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//访问刚出队的元素</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Queue<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token operator">-&gt;</span>LChild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//如果有左孩子，左孩子先入队列</span>
            Queue<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>Queue<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
            rear<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Queue<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token operator">-&gt;</span>RChild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//如果有右孩子，右孩子先后队列</span>
            Queue<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>Queue<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>
            rear<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        front<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//出队</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>基于栈的递归消除</p> <ul><li><p><strong>中序</strong>遍历二叉树的非递归算法</p> <p>注意：中序遍历法（非递归）需要设置一个堆栈，用于保留结点的指针，以便于在遍历完某个结点的左孩子树后，由该指针找到该结点的右子树。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//直接实现栈操作</span>
<span class="token comment">/*算法思想：从根结点开始，只要当前结点存在或者栈不空,循环：
1. 从当前结点开始，进栈并遍历左子树，直到左子树为空
2. 退栈并访问（栈先进后出）
3. 遍历右子树*/</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">m</span> <span class="token expression"><span class="token number">10</span>    </span><span class="token comment">//栈的空间大小   </span></span>
<span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiTree s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义栈</span>
    <span class="token keyword">int</span> top<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//栈顶指针</span>
    BiTree p<span class="token punctuation">;</span>
    p<span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token keyword">do</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//遍历左子树</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">&gt;</span>m<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">;</span>
            top<span class="token operator">++</span><span class="token punctuation">;</span>
            s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//栈不为空</span>
            p<span class="token operator">=</span>s<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
            top<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token function">Visit</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span>top<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><p><img src="/assets/img/22.849a70d4.jpg" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//调用栈操作的函数</span>

<span class="token comment">//中序</span>
<span class="token comment">/*算法思想：从根结点开始，只要当前结点存在或者栈不空，则循环
1.如果当前结点存在，则进栈并遍历左子树
2.否则退栈并访问，然后遍历右子树*/</span>
<span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Stack S<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p<span class="token punctuation">;</span>
    p<span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">Visit</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


</code></pre></div></li> <li><p>先序遍历非递归算法</p> <p><img src="/assets/img/23.6de625c2.png" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//先序遍历</span>
<span class="token comment">/**
   * @brief 思路：当栈不为空或者树的孩子不为空时，循环以下内容：
   * 1.访问当前结点的data值
   * 2.先访问左孩子，如果左孩子存在，则访问data，并将其指针入栈
   * 3.如果孩子不存在，则退栈，并访问右孩子
   */</span>
<span class="token keyword">void</span> <span class="token function">pre_order</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Stack S<span class="token punctuation">;</span>
    <span class="token function">init_stack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    BiTree p<span class="token punctuation">;</span>
    p<span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span><span class="token operator">!</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">visit_node</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>后序非递归遍历算法</p> <p><img src="/assets/img/24.585e08c1.jpg" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/**
*@brief:从根节点开始，只要当前结点存在，或者栈不空，则循环
*1.从当前结点开始，进栈并遍历左子树，直到左子树为空
*2.如果栈顶结点的右子树为空，或者栈顶结点的右孩子为刚访问过的结点，则退栈并访问，然后将当前结点的指针置为空
*3.否则遍历右子树
*/</span>
<span class="token function">GetTop</span><span class="token punctuation">(</span>Stack <span class="token operator">*</span>S<span class="token punctuation">,</span>BiTree <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token operator">*</span>q<span class="token punctuation">;</span>
    Stack S<span class="token punctuation">;</span>
    q<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    p<span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span> <span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>p<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                q<span class="token operator">=</span>p<span class="token punctuation">;</span>
                <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ol> <h2 id="线索二叉树-略"><a href="#线索二叉树-略" class="header-anchor">#</a> 线索二叉树（略</h2> <ol><li><p>基本概念：充分利用二叉树链表中的空链域，将遍历过程中结点的前驱、后继信息保存下来</p> <p><img src="/assets/img/25.d4e195e8.png" alt="An image"></p> <ul><li>线索：指向前驱、后继结点的指针</li> <li>线索化：对二叉树一某种次序进行遍历并加上线索的过程</li></ul></li> <li><p>二叉树的线索化</p> <ul><li><p>中序线索化：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/**
算法思想：首先创建一个二叉树，然后线索化
1.采用中序递归遍历法遍历算法框架
2.设置有一个指针pre，始终记录刚刚访问过的结点
3.若当前结点的左子域为空，则让左子域指向pre
4.若当前结点的右子域，则让右子域指向当前结点
5.pre=root*/</span>
BiTreeNode <span class="token operator">*</span>pre<span class="token punctuation">;</span><span class="token comment">//全局变量</span>
<span class="token keyword">void</span> <span class="token function">Inthread</span><span class="token punctuation">(</span>BiTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">Inthread</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            root<span class="token operator">-&gt;</span>Ltag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
            root<span class="token operator">-&gt;</span>LChild<span class="token operator">=</span>pre<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>pre<span class="token operator">-&gt;</span>RChild<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            pre<span class="token operator">-&gt;</span>RChild<span class="token operator">=</span>root<span class="token punctuation">;</span>
            pre<span class="token operator">-&gt;</span>Rtag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pre<span class="token operator">=</span>root<span class="token punctuation">;</span>
        <span class="token function">Inthread</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>(中序)线索二叉树中寻找前驱、后继结点</p> <p><img src="/assets/img/26.d6e889e5.jpg" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//找前驱结点</span>
<span class="token comment">/*算法思想：
当 Ltage==1时，即LChild指向前驱
当 Ltage==0时，即LChild指向左孩子，此时，该节点的前驱是，左子树的“最右下端”的结点*/</span>
BiTNode <span class="token operator">*</span><span class="token function">InPre</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiTNode <span class="token operator">*</span>pre<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>Ltag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
        pre<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>q<span class="token operator">-&gt;</span>Rtag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>q<span class="token operator">=</span>q<span class="token operator">-&gt;</span>RChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre<span class="token operator">=</span>q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//找后继结点</span>
<span class="token comment">/*算法思想：
当Rtag==1时，RChild指向后继；
当Rtag==0时，RChild指向右孩子，此时，该结点的后继是右子树的“最左下端”的结点
*/</span>
BiTNode <span class="token operator">*</span><span class="token function">InNext</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiTNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>Rtag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
        next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>RChild<span class="token punctuation">;</span>q<span class="token operator">-&gt;</span>Ltag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>q<span class="token operator">=</span>q<span class="token operator">-&gt;</span>LChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        next<span class="token operator">=</span>q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>遍历中序线索树</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//在中序线索树上求中序遍历的第一个结点</span>
BiTNode <span class="token operator">*</span><span class="token function">InFirst</span><span class="token punctuation">(</span>BiTree Bt<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiTNode <span class="token operator">*</span>p<span class="token operator">=</span>Bt<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>LChild<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>LChild<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//遍历中序二叉线索树</span>
<span class="token keyword">void</span> <span class="token function">TInOnder</span><span class="token punctuation">(</span>BiTree Bt<span class="token punctuation">)</span><span class="token punctuation">{</span>
    BiTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    p<span class="token operator">=</span><span class="token function">InFirst</span><span class="token punctuation">(</span>Bt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">=</span><span class="token function">InNext</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h2 id="树、森林和二叉树的关系"><a href="#树、森林和二叉树的关系" class="header-anchor">#</a> 树、森林和二叉树的关系</h2> <ol><li><p>树的存储结构</p> <ul><li><p>双亲表示法</p> <p><img src="/assets/img/27.6f5ee63e.png" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TNode</span><span class="token punctuation">{</span>
    DataType data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>TNode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    TNode tree<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> nodenum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ParentTree<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>孩子表示法</p> <p><img src="/assets/img/28.b3b2841a.png" alt="An image"></p> <p><img src="/assets/img/29.987c62c7.png" alt="An image"></p></li> <li><p>孩子兄弟表示法</p> <p><img src="/assets/img/30.0ccdf8a4.png" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">{</span>
    DataType data<span class="token punctuation">;</span>
    Struct CSNode <span class="token operator">*</span>FirstChild<span class="token punctuation">;</span><span class="token comment">//第一个孩子</span>
    Struct CSNode <span class="token operator">*</span>Nextsibling<span class="token punctuation">;</span><span class="token comment">//下一个兄弟</span>
<span class="token punctuation">}</span>CSNode<span class="token punctuation">,</span><span class="token operator">*</span>CSTree<span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>树、森林和二叉树的相互转化</p> <ul><li><p>树转化成二叉树（<strong>略</strong>）</p> <p>相邻兄弟之间相连，只保留双亲结点与都一个孩子之间的连线</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/*
树转二叉树
使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdbool.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> DataType<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>
    DataType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> left<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
<span class="token comment">//普通树节点的定义如下：</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_CHILDREN_NUM</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    DataType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">_CSNode</span> <span class="token operator">*</span>children<span class="token punctuation">[</span>MAX_CHILDREN_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>CSNode<span class="token punctuation">;</span>
<span class="token comment">/*其中，子树的根节点的指针存放在children数组的前k个元素中，
即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，
子树根结点分别保存在children[0]至children[i-1]中。*/</span>

<span class="token comment">//队列相关定义及操作如下：</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment">//指向数组内元素的游标</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Queue<span class="token punctuation">;</span>

Queue<span class="token operator">*</span> <span class="token function">create_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建队列</span>
bool <span class="token function">is_empty_queue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//队为空返回true,不为空时返回false</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">del_queue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结点指针出队</span>
<span class="token keyword">void</span> <span class="token function">add_queue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结点指针入队</span>
<span class="token keyword">void</span> <span class="token function">free_queue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放队列</span>
<span class="token comment">/*transform函数定义如下：
其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点*/</span>

BiTNode<span class="token operator">*</span> <span class="token function">transform</span><span class="token punctuation">(</span>CSNode <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    Queue <span class="token operator">*</span>que<span class="token punctuation">,</span> <span class="token operator">*</span>bque<span class="token punctuation">;</span>
    BiTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">//二叉树根结点创立 </span>
    <span class="token comment">//小心点, 记得分配空间 </span>
    <span class="token comment">//为什么想到建立二叉树结点?</span>
    <span class="token comment">//普通树结点和二叉树结点无法强制类型转换 </span>
    p <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>left <span class="token operator">=</span> p<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
       
    que <span class="token operator">=</span> <span class="token function">create_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bque <span class="token operator">=</span> <span class="token function">create_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//建立双队目的在于建立有序二叉结点序列 </span>
    <span class="token function">add_queue</span><span class="token punctuation">(</span>que<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add_queue</span><span class="token punctuation">(</span>bque<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
     
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_empty_queue</span><span class="token punctuation">(</span>que<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        BiTree bq<span class="token punctuation">;</span><span class="token comment">//创建二叉树队列头结点(根结点) </span>
        bq <span class="token operator">=</span> <span class="token function">del_queue</span><span class="token punctuation">(</span>bque<span class="token punctuation">)</span><span class="token punctuation">;</span>
        CSNode <span class="token operator">*</span>q<span class="token punctuation">;</span>
        q <span class="token operator">=</span> <span class="token function">del_queue</span><span class="token punctuation">(</span>que<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//第一次执行该操作就相当于建立了二叉树的根</span>
        <span class="token comment">//后来就相当于把最前面的结点提出来（队列是先进先出）    </span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
        BiTNode <span class="token operator">*</span>former <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//former用于记录二叉树的前一个结点</span>
        BiTNode <span class="token operator">*</span>node<span class="token punctuation">;</span><span class="token comment">//node用于记录当前结点</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>q<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
                node <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> q<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
                node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> 
                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//第一个孩子作为左孩子</span>
                    bq<span class="token operator">-&gt;</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token keyword">else</span><span class="token comment">//其他作为上一个孩子的右孩子</span>
                    former<span class="token operator">-&gt;</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
                former<span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token function">add_queue</span><span class="token punctuation">(</span>bque<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">add_queue</span><span class="token punctuation">(</span>que<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            
        <span class="token punctuation">}</span>     
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>que<span class="token operator">-&gt;</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>que<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>bque<span class="token operator">-&gt;</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>bque<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>森林转化为二叉树</p> <p>森林：若干树的集合</p> <p>向将每棵树转化成相应的二叉树，把后一棵树的根结点作为前一棵树的根结点的右孩子</p></li> <li><p>二叉树还原为树或森林:P186</p></li></ul></li> <li><p>树与森林的遍历</p> <ul><li><p>树的遍历：以孩子兄弟链表实现树的先根遍历</p> <p>树的先序遍历顺序相当于转化成的二叉树的中序遍历</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//方法一</span>
<span class="token keyword">void</span> <span class="token function">RootFirst</span><span class="token punctuation">(</span>CSTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">=</span>root<span class="token operator">-&gt;</span>FirstChild<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">RootFirst</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>Nextsibling<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//方法二</span>
<span class="token keyword">void</span> <span class="token function">RootFirst</span><span class="token punctuation">(</span>CSTree root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">RootFirst</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>FirstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">RootFirst</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>Nextsibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>森林的遍历</p></li></ul></li></ol> <h2 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="header-anchor">#</a> 哈夫曼树及其应用</h2> <h3 id="哈夫曼树"><a href="#哈夫曼树" class="header-anchor">#</a> 哈夫曼树</h3> <ol><li><p>哈夫曼树</p> <p>：由n个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树</p> <p>基本概念：</p> <ul><li>路径长度：根结点到该结点所经过的分支数目(数线段个数)</li> <li>权：weight</li> <li>带权路径长度(PL)：路径长度与权的乘积</li> <li>树的带权路径长度（WPL）：根到所有<strong>叶子结点</strong>的各个带权路径长度之和</li></ul></li> <li><p>构造哈夫曼树：</p> <p>原则：权值越大的叶结点越靠近根结点，权值越小的叶结点月远离根结点</p></li> <li><p>数据类型</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//使用静态三叉树</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">20</span>      </span><span class="token comment">//叶子结点的最大值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span> <span class="token expression"><span class="token number">2</span><span class="token operator">*</span>N<span class="token operator">-</span><span class="token number">1</span>   </span><span class="token comment">//所有结点的最大值</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>
    <span class="token keyword">int</span> LChild<span class="token punctuation">;</span>
    <span class="token keyword">int</span> RChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>HTNode<span class="token punctuation">,</span>HufffmanTree<span class="token punctuation">[</span>M<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>创建哈夫曼树<img src="/assets/img/31.2f638405.png" alt="An image"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">CreateHuffmanTree</span><span class="token punctuation">(</span>HuffmanTree ht<span class="token punctuation">,</span><span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//构造哈夫曼树ht[M+1],w[n]存放n个权值</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>LChild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>RChild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    m<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">select</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span><span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//该函数作用：在h[1]~h[i-1]的范围内选择两个parent为0，且weight最小的结点，其序号分别赋值给s1,s2</span>
        
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>ht<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">+</span>ht<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>LChild<span class="token operator">=</span>s1<span class="token punctuation">;</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>RChild<span class="token operator">=</span>s2
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">CreateHT</span><span class="token punctuation">(</span>HTNode ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>k<span class="token punctuation">,</span>LNode<span class="token punctuation">,</span>RNode<span class="token punctuation">;</span>
    <span class="token keyword">double</span> min1<span class="token punctuation">,</span>min2<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>LChild<span class="token operator">=</span>ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>RChild<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//构造哈夫曼树的n-1个结点</span>
        min1<span class="token operator">=</span>min2<span class="token operator">=</span>INFINITE<span class="token punctuation">;</span>
        LNode<span class="token operator">=</span>RNode<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//k&lt;i-1</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;=</span>min1<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    min2<span class="token operator">=</span>min1<span class="token punctuation">;</span>
                    RNode<span class="token operator">=</span>INode<span class="token punctuation">;</span>
                    min1<span class="token operator">=</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
                    LNode<span class="token operator">=</span>k<span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;=</span>min2<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    min2<span class="token operator">=</span>ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
                    RNode<span class="token operator">=</span>k<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>ht<span class="token punctuation">[</span>LNode<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">+</span>ht<span class="token punctuation">[</span>RNode<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
      ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>LChild<span class="token operator">=</span>LNode<span class="token punctuation">;</span>
      ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>RChild<span class="token operator">=</span>RNode<span class="token punctuation">;</span>
      ht<span class="token punctuation">[</span>LNode<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>ht<span class="token punctuation">[</span>RNode<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意：哈夫曼树的特点：</p> <ul><li>n个叶子的哈夫曼树的形态不唯一，但是带权路径长度是相同的</li> <li>权值越大的结点离根越近</li> <li>哈夫曼树只有度为0或2的结点，没有度为1的结点</li></ul></li></ol> <h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="header-anchor">#</a> 哈夫曼编码</h3> <ol><li><p>基础概念：</p> <ul><li>编码：将文件字符转化为二进制位串（数据压缩）</li> <li>前缀编码：采用不等长编码，出现次数多的用短码，且任一编码不能是另一编码的前缀</li></ul></li> <li><p>哈夫曼编码</p> <ul><li>以字符出现次数为权值构造一棵哈夫曼树，规定左分支编码为0，右分支编码为1，编码就为：从根到该字符所在的叶子结点的路径上的分支序号构成的序列</li> <li><img src="/assets/img/32.b6a5865a.png" alt="An image"></li></ul></li> <li><p>哈夫曼编码的算法实现</p> <ul><li><p>算法逻辑：</p> <p><img src="/assets/img/33.6fa5166c.png" alt="An image"></p></li> <li></li></ul> <div class="language-c extra-class"><pre class="language-c"><code> <span class="token comment">/*哈夫曼编码的存储结构*/</span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEN</span> <span class="token expression"><span class="token number">100</span></span></span>
 <span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
     <span class="token keyword">char</span> ch<span class="token punctuation">;</span>  <span class="token comment">//存放字符</span>
     <span class="token keyword">char</span> code<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存放编码</span>
 <span class="token punctuation">}</span>TCode<span class="token punctuation">;</span>
 TCode CodeBook<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//编码本</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/*编码*/</span>
<span class="token keyword">void</span> <span class="token function">encoding</span><span class="token punctuation">(</span>HTNode ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>TCode book<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span> <span class="token comment">//首先存放编码结束符</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>idx<span class="token punctuation">,</span>p<span class="token punctuation">;</span>
    <span class="token comment">//其中，idx指向当前结点，p指向当前结点的parent</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        book<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ch<span class="token operator">=</span>ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ch<span class="token punctuation">;</span>
        idx<span class="token operator">=</span>i<span class="token punctuation">;</span>
        j<span class="token operator">=</span>n<span class="token punctuation">;</span><span class="token comment">//得到的是逆序，所以j倒着计数</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">=</span>ht<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ht<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>LChild<span class="token operator">==</span>idx<span class="token punctuation">)</span><span class="token punctuation">{</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>
                str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'0'</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>
                str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'1'</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            idx<span class="token operator">=</span>p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>book<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>code<span class="token punctuation">,</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/*解码*/</span>

</code></pre></div></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tech/structure/Stack-Queue.html" class="prev">
        Stack-Queue
      </a></span> <span class="next"><a href="/tech/structure/Graph.html">
        Graph
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.fd63b75d.js" defer></script><script src="/assets/js/2.fc10bb63.js" defer></script><script src="/assets/js/1.13179e0f.js" defer></script><script src="/assets/js/11.1eb29c58.js" defer></script>
  </body>
</html>
