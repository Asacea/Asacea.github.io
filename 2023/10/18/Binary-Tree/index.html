<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhang Qianyu">







<title>Binary-Tree | space</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    










  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Space.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/tech/">tech</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/C/">
                            C
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/Algorithm/">
                            Algorithm
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/data-structure/">
                            data structure
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Binary-Tree
            
            
        </div>
        <span class="post-date">
            Oct 18, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="第六章：树与二叉树"><a href="#第六章：树与二叉树" class="headerlink" title="第六章：树与二叉树"></a>第六章：树与二叉树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ol>
<li><p>关系：一对多，层次化</p>
</li>
<li><p>基本概念：</p>
<ul>
<li>根：没有前驱，有一个或者多个后继</li>
<li>子树：只有一个前驱，有一个或者多个后继，子树之间互不相交</li>
<li>结点的度：一个结点的子树个数    ； 树的度：树中所有结点的度的最大值</li>
<li>结点的层次：从根结点开始定义，根的层次为1 ，它的直接后继的层次为2，依次类推</li>
<li>树的高度（深度）：层次的最大值</li>
<li>结点的层序编号：将树中的结点按从上层到下层、同层从左到右的次序排成一个线性序列，依次给它们编以连续的自然数</li>
<li>结点之间的层次关系：<ul>
<li>双亲结点：结点的直接前驱</li>
<li>前辈,后辈：比较结点的层次</li>
</ul>
</li>
</ul>
</li>
<li><p>树的数据类型</p>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ol>
<li><p>定义：</p>
<ul>
<li>每个结点的度都不大于2；</li>
<li>每个结点的孩子结点次序都不能任意颠倒（左子树和右子树）</li>
</ul>
</li>
<li><p>性质：</p>
<ol>
<li><p>在二叉树的第i层上至多有2^(i-1)个结点</p>
</li>
<li><p>深度为k的二叉树至多有2^k-1个结点</p>
</li>
<li><p>任意一棵二叉树T，若终端节点(度数为0的结点)数为m，而其度数为2的节点数为n，则m&#x3D;n+1;</p>
</li>
<li><p>满二叉树：深度为k且有2^k-1个结点的二叉树</p>
</li>
<li><p>完全二叉树：深度为k，结点数为n，结点位置序号与相同高度的满二叉树一一对应</p>
<img src="/images/blog_images/Basic_Algorithms/17.jpg" style="zoom:50%;" />
</li>
<li><p>具有n个结点的完全二叉树的深度为(log2 n)+1</p>
</li>
</ol>
</li>
<li><p>存储结构：</p>
<ul>
<li><p>顺序存储</p>
</li>
<li><p>链式存储：</p>
<img src="/images/blog_images/Basic_Algorithms/18.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">RChild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ol>
<li><p>遍历（左右孩子和根的访问顺序）</p>
<ul>
<li><p>先序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Data-&gt;L-&gt;R</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        PreOrder(root-&gt;LChild);</span><br><span class="line">        PreOrder(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//L-&gt;Data-&gt;R</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        InOrder(root-&gt;LChild);</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        InOrder(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//L-&gt;R-&gt;Data</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        PostOrder(root-&gt;LChild);</span><br><span class="line">        PostOrder(root-&gt;RChild);</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历算法的应用</p>
<ul>
<li><p>输出二叉树当中的叶子结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;RChild==<span class="literal">NULL</span>)</span><br><span class="line">            print(root-&gt;data);</span><br><span class="line">        PreOrder(root-&gt;LChild);</span><br><span class="line">        PreOrder(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计叶子结点的数目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：递归遍历统计</span></span><br><span class="line"><span class="type">int</span> LeafCount=<span class="number">0</span> ; <span class="comment">//全局变量，用于统计叶子结点的数目</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leaf</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        leaf(root-&gt;LChild);</span><br><span class="line">        leaf(root-&gt;RChild);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;RChild==<span class="literal">NULL</span>)</span><br><span class="line">            LeafCount++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：分治算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">leaf</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="type">int</span> LeafCnt;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//空树</span></span><br><span class="line">        LeafCnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;RChild==<span class="literal">NULL</span>)<span class="comment">//叶子结点</span></span><br><span class="line">        LeafCnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LeafCnt=leaf(root-&gt;LChild)+leaf(root-&gt;RChild);</span><br><span class="line">    <span class="keyword">return</span> LeafCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立二叉链表方式存储的二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *bi)</span>&#123;<span class="comment">//这里传的是二级指针</span></span><br><span class="line">   <span class="comment">//假设data的类型是字符型</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        *bi=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *bi=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*bi)-&gt;data=ch;</span><br><span class="line">        CreateBiTree(&amp;((*bi)-&gt;LChild));</span><br><span class="line">        CreateBiTree(&amp;((*bi)-&gt;RChild));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求二叉树的高度</p>
<p>逻辑 ：高度就是二叉树的层次的最大值，或者说左右子树的高度最大值+1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分沿法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PostTreeDepth</span><span class="params">(BiTree bt)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hl,hr,max;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        hl=PostTreeDepth(bt-&gt;LChild);</span><br><span class="line">        hr=PostTreeDepth(bt-&gt;RChild);</span><br><span class="line">        max=hl&gt;hr?hl:hr;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">int</span> depht=<span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTreeDepth</span><span class="params">(BiTree bt,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h&gt;depth)</span><br><span class="line">            depht=h;</span><br><span class="line">        PreTreeDepth(bt-&gt;LChild,h+<span class="number">1</span>);</span><br><span class="line">        PreTreeDepth(bt-&gt;RChild,h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按横向树形显示二叉树<img src="/images/blog_images/Basic_Algorithms/19.jpg" style="zoom:20%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintTree</span><span class="params">(BiTree bt,<span class="type">int</span> nLayer)</span>&#123;<span class="comment">//实现先右后左</span></span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nLayer;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,bt-&gt;data);</span><br><span class="line">    PrintTree(bt-&gt;RChild,nLayer+<span class="number">1</span>);</span><br><span class="line">    PrintTree(bt-&gt;LChild,nlayer+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>层次遍历法(<strong>略</strong>)</p>
<img src="/images/blog_images/Basic_Algorithms/20.png" style="zoom:50%;" />

<img src="/images/blog_images/Basic_Algorithms/21.png" style="zoom:40%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree bt)</span>&#123;</span><br><span class="line">    BiTree Queue[MAXNODE];  <span class="comment">//定义队列，队列先进先出</span></span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)    <span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    front=<span class="number">0</span>;</span><br><span class="line">    rear=<span class="number">0</span>;</span><br><span class="line">    Queue[rear]=bt;  <span class="comment">//根结点入队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">while</span>(rear!=front)&#123;<span class="comment">//队列不空，继续遍历</span></span><br><span class="line">        visit(Queue[front]-&gt;data);  <span class="comment">//访问刚出队的元素</span></span><br><span class="line">        <span class="keyword">if</span>(Queue[front]-&gt;LChild!=<span class="literal">NULL</span>)&#123;  <span class="comment">//如果有左孩子，左孩子先入队列</span></span><br><span class="line">            Queue[rear]=Queue[front]-&gt;LChild;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Queue[front]-&gt;RChild!=<span class="literal">NULL</span>)&#123;<span class="comment">//如果有右孩子，右孩子先后队列</span></span><br><span class="line">            Queue[rear]=Queue[front]-&gt;RChild;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;  <span class="comment">//出队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>基于栈的递归消除</p>
<ul>
<li><p><strong>中序</strong>遍历二叉树的非递归算法</p>
<p>注意：中序遍历法（非递归）需要设置一个堆栈，用于保留结点的指针，以便于在遍历完某个结点的左孩子树后，由该指针找到该结点的右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接实现栈操作</span></span><br><span class="line"><span class="comment">/*算法思想：从根结点开始，只要当前结点存在或者栈不空,循环：</span></span><br><span class="line"><span class="comment">1. 从当前结点开始，进栈并遍历左子树，直到左子树为空</span></span><br><span class="line"><span class="comment">2. 退栈并访问（栈先进后出）</span></span><br><span class="line"><span class="comment">3. 遍历右子树*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 10    <span class="comment">//栈的空间大小   </span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    BiTree s[m];<span class="comment">//定义栈</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>; <span class="comment">//栈顶指针</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;<span class="comment">//遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span>(top&gt;m)  <span class="keyword">return</span> ;</span><br><span class="line">            top++;</span><br><span class="line">            s[top]=p;</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top!=<span class="number">0</span>)&#123; <span class="comment">//栈不为空</span></span><br><span class="line">            p=s[top];</span><br><span class="line">            top--;</span><br><span class="line">            Visit(p-&gt;data);</span><br><span class="line">            p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>||top!=<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/22.jpg" style="zoom:200%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用栈操作的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="comment">/*算法思想：从根结点开始，只要当前结点存在或者栈不空，则循环</span></span><br><span class="line"><span class="comment">1.如果当前结点存在，则进栈并遍历左子树</span></span><br><span class="line"><span class="comment">2.否则退栈并访问，然后遍历右子树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    BiTree p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Push(&amp;S,p);</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(&amp;S,&amp;p);</span><br><span class="line">            Visit(p-&gt;data);</span><br><span class="line">            p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>先序遍历非递归算法</p>
<img src="/images/blog_images/Basic_Algorithms/23.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 思路：当栈不为空或者树的孩子不为空时，循环以下内容：</span></span><br><span class="line"><span class="comment">   * 1.访问当前结点的data值</span></span><br><span class="line"><span class="comment">   * 2.先访问左孩子，如果左孩子存在，则访问data，并将其指针入栈</span></span><br><span class="line"><span class="comment">   * 3.如果孩子不存在，则退栈，并访问右孩子</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre_order</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    init_stack(&amp;S);</span><br><span class="line">    BiTree p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!is_empty(&amp;S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            visit_node(p);</span><br><span class="line">            push(&amp;S,p);</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pop(&amp;S,&amp;p);</span><br><span class="line">            p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序非递归遍历算法</p>
<img src="/images/blog_images/Basic_Algorithms/24.jpg" style="zoom: 50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*@brief:从根节点开始，只要当前结点存在，或者栈不空，则循环</span></span><br><span class="line"><span class="comment">*1.从当前结点开始，进栈并遍历左子树，直到左子树为空</span></span><br><span class="line"><span class="comment">*2.如果栈顶结点的右子树为空，或者栈顶结点的右孩子为刚访问过的结点，则退栈并访问，然后将当前结点的指针置为空</span></span><br><span class="line"><span class="comment">*3.否则遍历右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GetTop(Stack *S,BiTree *p);</span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    BiNode *p,*q;</span><br><span class="line">    Stack S;</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    p=root;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>|| !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Push(&amp;S,p);</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            GetTop(&amp;S,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;RChild==<span class="literal">NULL</span>||p-&gt;RChild==q)&#123;</span><br><span class="line">                visit(p-&gt;data);</span><br><span class="line">                q=p;</span><br><span class="line">                Pop(&amp;S,&amp;p);</span><br><span class="line">                p=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p=p-&gt;RChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="线索二叉树（略"><a href="#线索二叉树（略" class="headerlink" title="线索二叉树（略"></a>线索二叉树（略</h3><ol>
<li><p>基本概念：充分利用二叉树链表中的空链域，将遍历过程中结点的前驱、后继信息保存下来</p>
<img src="/images/blog_images/Basic_Algorithms/25.png" style="zoom:50%;" />

<ul>
<li>线索：指向前驱、后继结点的指针</li>
<li>线索化：对二叉树一某种次序进行遍历并加上线索的过程</li>
</ul>
</li>
<li><p>二叉树的线索化</p>
<ul>
<li><p>中序线索化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">算法思想：首先创建一个二叉树，然后线索化</span></span><br><span class="line"><span class="comment">1.采用中序递归遍历法遍历算法框架</span></span><br><span class="line"><span class="comment">2.设置有一个指针pre，始终记录刚刚访问过的结点</span></span><br><span class="line"><span class="comment">3.若当前结点的左子域为空，则让左子域指向pre</span></span><br><span class="line"><span class="comment">4.若当前结点的右子域，则让右子域指向当前结点</span></span><br><span class="line"><span class="comment">5.pre=root*/</span></span><br><span class="line">BiTreeNode *pre;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inthread</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        Inthread(root-&gt;LChild);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root-&gt;Ltag=<span class="number">1</span>;</span><br><span class="line">            root-&gt;LChild=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;RChild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;RChild=root;</span><br><span class="line">            pre-&gt;Rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        Inthread(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>(中序)线索二叉树中寻找前驱、后继结点</p>
<img src="/images/blog_images/Basic_Algorithms/26.jpg" style="zoom:15%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找前驱结点</span></span><br><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">当 Ltage==1时，即LChild指向前驱</span></span><br><span class="line"><span class="comment">当 Ltage==0时，即LChild指向左孩子，此时，该节点的前驱是，左子树的“最右下端”的结点*/</span></span><br><span class="line">BiTNode *<span class="title function_">InPre</span><span class="params">(BiTNode *p)</span>&#123;</span><br><span class="line">    BiTNode *pre;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Ltag==<span class="number">1</span>)</span><br><span class="line">        pre=p-&gt;LChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(q=p-&gt;LChild;q-&gt;Rtag==<span class="number">0</span>;q=q-&gt;RChild);</span><br><span class="line">        pre=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找后继结点</span></span><br><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">当Rtag==1时，RChild指向后继；</span></span><br><span class="line"><span class="comment">当Rtag==0时，RChild指向右孩子，此时，该结点的后继是右子树的“最左下端”的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BiTNode *<span class="title function_">InNext</span><span class="params">(BiTNode *p)</span>&#123;</span><br><span class="line">    BiTNode *next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rtag==<span class="number">1</span>)</span><br><span class="line">        next=p-&gt;RChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(q=p-&gt;RChild;q-&gt;Ltag==<span class="number">0</span>;q=q-&gt;LChild);</span><br><span class="line">        next=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历中序线索树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在中序线索树上求中序遍历的第一个结点</span></span><br><span class="line">BiTNode *<span class="title function_">InFirst</span><span class="params">(BiTree Bt)</span>&#123;</span><br><span class="line">    BiTNode *p=Bt;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;LChild==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;LChild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历中序二叉线索树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TInOnder</span><span class="params">(BiTree Bt)</span>&#123;</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    p=InFirst(Bt);</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">        p=InNext(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="树、森林和二叉树的关系"><a href="#树、森林和二叉树的关系" class="headerlink" title="树、森林和二叉树的关系"></a>树、森林和二叉树的关系</h3><ol>
<li><p>树的存储结构</p>
<ul>
<li><p>双亲表示法</p>
<img src="/images/blog_images/Basic_Algorithms/27.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;TNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode tree[MAX];</span><br><span class="line">    <span class="type">int</span> nodenum;</span><br><span class="line">&#125;ParentTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>孩子表示法</p>
<img src="/images/blog_images/Basic_Algorithms/28.png" style="zoom:50%;" />

<img src="/images/blog_images/Basic_Algorithms/29.png" style="zoom:50%;" />
</li>
<li><p>孩子兄弟表示法</p>
<img src="/images/blog_images/Basic_Algorithms/30.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    Struct CSNode *FirstChild;<span class="comment">//第一个孩子</span></span><br><span class="line">    Struct CSNode *Nextsibling;<span class="comment">//下一个兄弟</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>树、森林和二叉树的相互转化</p>
<ul>
<li><p>树转化成二叉树（<strong>略</strong>）</p>
<p>相邻兄弟之间相连，只保留双亲结点与都一个孩子之间的连线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">树转二叉树</span></span><br><span class="line"><span class="comment">使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="comment">//普通树节点的定义如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CHILDREN_NUM 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CSNode</span> *<span class="title">children</span>[<span class="title">MAX_CHILDREN_NUM</span>];</span></span><br><span class="line">&#125;CSNode;</span><br><span class="line"><span class="comment">/*其中，子树的根节点的指针存放在children数组的前k个元素中，</span></span><br><span class="line"><span class="comment">即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，</span></span><br><span class="line"><span class="comment">子树根结点分别保存在children[0]至children[i-1]中。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列相关定义及操作如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">//指向数组内元素的游标</span></span><br><span class="line">    <span class="type">void</span> **<span class="built_in">array</span>;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">create_queue</span><span class="params">()</span>; <span class="comment">//创建队列</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty_queue</span><span class="params">(Queue *tree)</span>; <span class="comment">//队为空返回true,不为空时返回false</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">del_queue</span><span class="params">(Queue *tree)</span>; <span class="comment">//结点指针出队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_queue</span><span class="params">(Queue *tree, <span class="type">void</span> *node)</span>; <span class="comment">//结点指针入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_queue</span><span class="params">(Queue *tree)</span>; <span class="comment">//释放队列</span></span><br><span class="line"><span class="comment">/*transform函数定义如下：</span></span><br><span class="line"><span class="comment">其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点*/</span></span><br><span class="line"></span><br><span class="line">BiTNode* <span class="title function_">transform</span><span class="params">(CSNode *root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Queue *que, *bque;</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    <span class="comment">//二叉树根结点创立 </span></span><br><span class="line">    <span class="comment">//小心点, 记得分配空间 </span></span><br><span class="line">    <span class="comment">//为什么想到建立二叉树结点?</span></span><br><span class="line">    <span class="comment">//普通树结点和二叉树结点无法强制类型转换 </span></span><br><span class="line">    p = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    p-&gt;data = root-&gt;data;</span><br><span class="line">    p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">       </span><br><span class="line">    que = create_queue();</span><br><span class="line">    bque = create_queue();</span><br><span class="line">    <span class="comment">//建立双队目的在于建立有序二叉结点序列 </span></span><br><span class="line">    add_queue(que, root);</span><br><span class="line">    add_queue(bque, p);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(!is_empty_queue(que))&#123;</span><br><span class="line">        BiTree bq;<span class="comment">//创建二叉树队列头结点(根结点) </span></span><br><span class="line">        bq = del_queue(bque);</span><br><span class="line">        CSNode *q;</span><br><span class="line">        q = del_queue(que);</span><br><span class="line">        <span class="comment">//第一次执行该操作就相当于建立了二叉树的根</span></span><br><span class="line">        <span class="comment">//后来就相当于把最前面的结点提出来（队列是先进先出）    </span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">        BiTNode *former = <span class="literal">NULL</span>;<span class="comment">//former用于记录二叉树的前一个结点</span></span><br><span class="line">        BiTNode *node;<span class="comment">//node用于记录当前结点</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;q-&gt;children[i]!=<span class="literal">NULL</span>; i++)&#123; </span><br><span class="line">                node = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">                node-&gt;data = q-&gt;children[i]-&gt;data;</span><br><span class="line">                node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                node-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="comment">//第一个孩子作为左孩子</span></span><br><span class="line">                    bq-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//其他作为上一个孩子的右孩子</span></span><br><span class="line">                    former-&gt;right = node;</span><br><span class="line">                former= node;</span><br><span class="line">                add_queue(bque, node);</span><br><span class="line">                add_queue(que, q-&gt;children[i]);            </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(que-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(que);</span><br><span class="line">    <span class="built_in">free</span>(bque-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(bque);   </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>森林转化为二叉树</p>
<p>森林：若干树的集合</p>
<p>向将每棵树转化成相应的二叉树，把后一棵树的根结点作为前一棵树的根结点的右孩子</p>
</li>
<li><p>二叉树还原为树或森林:P186</p>
</li>
</ul>
</li>
<li><p>树与森林的遍历</p>
<ul>
<li><p>树的遍历：以孩子兄弟链表实现树的先根遍历</p>
<p>树的先序遍历顺序相当于转化成的二叉树的中序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RootFirst</span><span class="params">(CSTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        p=root-&gt;FirstChild;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            RootFirst(p);</span><br><span class="line">            p=p-&gt;Nextsibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RootFirst</span><span class="params">(CSTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        RootFirst(root-&gt;FirstChild);</span><br><span class="line">        RootFirst(root-&gt;Nextsibling);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>森林的遍历</p>
</li>
</ul>
</li>
</ol>
<h3 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h3><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><ol>
<li><p>哈夫曼树</p>
<p>：由n个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树</p>
<p>基本概念：</p>
<ul>
<li>路径长度：根结点到该结点所经过的分支数目(数线段个数)</li>
<li>权：weight</li>
<li>带权路径长度(PL)：路径长度与权的乘积</li>
<li>树的带权路径长度（WPL）：根到所有<strong>叶子结点</strong>的各个带权路径长度之和</li>
</ul>
</li>
<li><p>构造哈夫曼树：</p>
<p>原则：权值越大的叶结点越靠近根结点，权值越小的叶结点月远离根结点</p>
</li>
<li><p>数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用静态三叉树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20      <span class="comment">//叶子结点的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2*N-1   <span class="comment">//所有结点的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> LChild;</span><br><span class="line">    <span class="type">int</span> RChild;</span><br><span class="line">&#125;HTNode,HufffmanTree[M+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建哈夫曼树<img src="/images/blog_images/Basic_Algorithms/31.png" style="zoom:50%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree ht,<span class="type">int</span> w[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//构造哈夫曼树ht[M+1],w[n]存放n个权值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ht[i].weight=w[i];</span><br><span class="line">        ht[i].parent=<span class="number">0</span>;</span><br><span class="line">        ht[i].LChild=<span class="number">0</span>;</span><br><span class="line">        ht[i].RChild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        select(ht,i<span class="number">-1</span>,&amp;s1,&amp;s2);<span class="comment">//该函数作用：在h[1]~h[i-1]的范围内选择两个parent为0，且weight最小的结点，其序号分别赋值给s1,s2</span></span><br><span class="line">        </span><br><span class="line">        ht[i].weight=ht[s1].weight+ht[s2].weight;</span><br><span class="line">        ht[s1].parent=i;</span><br><span class="line">        ht[s2].parent=i;</span><br><span class="line">        ht[i].LChild=s1;</span><br><span class="line">        ht[i].RChild=s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHT</span><span class="params">(HTNode ht[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,k,LNode,RNode;</span><br><span class="line">    <span class="type">double</span> min1,min2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)</span><br><span class="line">        ht[i].parent=ht[i].LChild=ht[i].RChild=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)&#123;<span class="comment">//构造哈夫曼树的n-1个结点</span></span><br><span class="line">        min1=min2=INFINITE;</span><br><span class="line">        LNode=RNode=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;i<span class="number">-1</span>;k++)&#123;<span class="comment">//k&lt;i-1</span></span><br><span class="line">            <span class="keyword">if</span>(ht[k].parent==<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span>(ht[k].weight&lt;=min1)&#123;</span><br><span class="line">                    min2=min1;</span><br><span class="line">                    RNode=INode;</span><br><span class="line">                    min1=ht[k].weight;</span><br><span class="line">                    LNode=k;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ht[k].weight&lt;=min2)&#123;</span><br><span class="line">                    min2=ht[i].weight;</span><br><span class="line">                    RNode=k;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ht[i].weight=ht[LNode].weight+ht[RNode].weight;</span><br><span class="line">      ht[i].LChild=LNode;</span><br><span class="line">      ht[i].RChild=RNode;</span><br><span class="line">      ht[LNode].parent=ht[RNode].parent=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：哈夫曼树的特点：</p>
<ul>
<li>n个叶子的哈夫曼树的形态不唯一，但是带权路径长度是相同的</li>
<li>权值越大的结点离根越近</li>
<li>哈夫曼树只有度为0或2的结点，没有度为1的结点</li>
</ul>
</li>
</ol>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><ol>
<li><p>基础概念：</p>
<ul>
<li>编码：将文件字符转化为二进制位串（数据压缩）</li>
<li>前缀编码：采用不等长编码，出现次数多的用短码，且任一编码不能是另一编码的前缀</li>
</ul>
</li>
<li><p>哈夫曼编码</p>
<ul>
<li>以字符出现次数为权值构造一棵哈夫曼树，规定左分支编码为0，右分支编码为1，编码就为：从根到该字符所在的叶子结点的路径上的分支序号构成的序列</li>
<li><img src="/images/blog_images/Basic_Algorithms/32.png" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>哈夫曼编码的算法实现</p>
<ul>
<li><p>算法逻辑：</p>
<img src="/images/blog_images/Basic_Algorithms/33.png" style="zoom:50%;" /></li>
<li> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*哈夫曼编码的存储结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;  <span class="comment">//存放字符</span></span><br><span class="line">    <span class="type">char</span> code[LEN];<span class="comment">//存放编码</span></span><br><span class="line">&#125;TCode;</span><br><span class="line">TCode CodeBook[LEN];  <span class="comment">//编码本</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编码*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encoding</span><span class="params">(HTNode ht[],TCode book[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str=(<span class="type">char</span>*)<span class="built_in">malloc</span>(n+<span class="number">1</span>);</span><br><span class="line">    str[n]=<span class="string">&#x27;\0&#x27;</span>; <span class="comment">//首先存放编码结束符</span></span><br><span class="line">    <span class="type">int</span> i,j,idx,p;</span><br><span class="line">    <span class="comment">//其中，idx指向当前结点，p指向当前结点的parent</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        book[i].ch=ht[i].ch;</span><br><span class="line">        idx=i;</span><br><span class="line">        j=n;<span class="comment">//得到的是逆序，所以j倒着计数</span></span><br><span class="line">        <span class="keyword">while</span>(p=ht[idx].parent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ht[p].LChild==idx)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                str[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">                str[j]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(book[i].code,&amp;str[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*解码*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2023/10/18/Graph/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/10/18/Array-Table/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
                © Zhang Qianyu | 
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
