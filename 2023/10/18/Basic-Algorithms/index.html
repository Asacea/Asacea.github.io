<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhang Qianyu">







<title>Basic-Algorithms | space</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    










  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Space.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/Me/">AboutMe</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/C/">
                            C
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/Algorithm/">
                            Algorithm
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/data-structure/">
                            data structure
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Basic-Algorithms
            
            
        </div>
        <span class="post-date">
            Oct 18, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="数据结构——用C语言描述"><a href="#数据结构——用C语言描述" class="headerlink" title="数据结构——用C语言描述"></a>数据结构——用C语言描述</h1><h2 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li>基本数据结构：集合、线性（表，一对一）、树形（一对多）、网状结构（多对多）</li>
<li>存储结构：顺序映象（一组连续单元）和非顺序映象</li>
</ol>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>执行时间</li>
<li>语句频度：该语句在一个算法中重复执行的次数</li>
<li>最坏时间复杂度：执行次数</li>
<li>空间复杂度：占用空间的数量级</li>
</ul>
<h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ol>
<li>特点：<ul>
<li>同一性：由同类元素组成</li>
<li>有穷性：由有限个元素组成</li>
<li>有序性：相邻元素之间存在序偶关系</li>
</ul>
</li>
</ol>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ol>
<li><p>顺序储存结构</p>
<p>这里的顺序表其实就是数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType elem[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> last;    <span class="comment">//记录线性表中最后一个元素在elem数组 当中的位置，空表置为-1，因此可以得出，线性表当中元素的实际个数=last+1，即顺序表的长度；</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>

<p>ai在线性表当中的序号为i，在顺序表对应的数组elem中的下标为i-1</p>
</li>
<li><p>定义变量的两种方法：</p>
<ul>
<li>SeqList类型的变量：<code>SeqList L;</code>。访问i号元素：<code>L.elem[i-1]</code>;最后一个元素的下标:<code>L.last</code>;顺序表的长度：<code>L.last+1</code></li>
<li>指针变量：<code>SeqList L1,*L;   L=&amp;L1</code> 。访问i号元素：<code>L-&gt;elem[i-1]</code>;顺序表的长度：<code>L-&gt;last+1</code></li>
</ul>
</li>
<li><p>基本运算</p>
<ul>
<li><p><strong>查找操作</strong>：</p>
<ol>
<li><p>按序号查找：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetData</span><span class="params">(SeqList L,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L.last)</span><br><span class="line">        <span class="keyword">return</span> L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按内容查找：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SeqList L,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=L.last)&amp;&amp;(L.elem[i]!=e))</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L.last)</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;  <span class="comment">//返回其序号</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//返回空置符-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度为O(n)</p>
</li>
</ol>
</li>
<li><p><strong>插入操作</strong>：</p>
<p>其实就是插入数组操作,先找到插入位置，然后将该位置后的元素都依次向后移动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsList</span><span class="params">(SeqList *L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L-&gt;last+<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;last&gt;=MAX_SIZA<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no space&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=L-&gt;last;k&gt;=i<span class="number">-1</span>;k--)<span class="comment">//倒序</span></span><br><span class="line">        L-&gt;elem[k+<span class="number">1</span>]=L-&gt;elem[k];</span><br><span class="line">    L-&gt;elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    L-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法分析：E为在长度为n的表中插入一个元素所需移动元素的平均次数。假设插入 任何位置的可能性相当，E&#x3D;n&#x2F;2</p>
</li>
<li><p>删除操作：</p>
<p>将目标位置的所有元素一次向前依次移动一位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DelList</span><span class="params">(SeqList *L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L-&gt;last+<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(k=i;k&lt;=L-&gt;last;k++)</span><br><span class="line">        L-&gt;elem[k<span class="number">-1</span>]=L-&gt;elem[k];</span><br><span class="line">     L-&gt;last--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E&#x3D;(n-1)&#x2F;2</p>
</li>
<li><p><strong>合并运算</strong>：</p>
<p>将两个顺序表合并成一个顺序表，所有顺序表元素都是非递减有序排列（即单调不减）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mergeList</span><span class="params">(SeqList *LA,SeqList *LB,SeqList *LC)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=LA-&gt;last&amp;&amp;j&lt;=LB-&gt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(LA-&gt;elem[i]&lt;=LB-&gt;elem[j])</span><br><span class="line">        &#123;</span><br><span class="line">            LC-&gt;elem[k]=LA-&gt;elem[i];</span><br><span class="line">            k++,i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LC-&gt;elem[k]=LB-&gt;elem[j];</span><br><span class="line">            k++,j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当某一表当中的元素有剩余的时候，将剩下的元素直接赋给LC</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=LA-&gt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        LC-&gt;elem[k]=LA-&gt;elem[i];</span><br><span class="line">        i++,k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=LB-&gt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        LC-&gt;elem[k]=LA-&gt;elem[j];</span><br><span class="line">        j++,k++;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><h4 id="单链表（略讲）"><a href="#单链表（略讲）" class="headerlink" title="单链表（略讲）"></a><strong>单链表</strong>（略讲）</h4><ul>
<li><p>结点的组成部分：数据域，指针域</p>
</li>
<li><p>头指针H指向首结点，最后一个结点的指针指向null</p>
<img src="/images/blog_images/Basic_Algorithms/1.jpg" style="zoom:50%;" />
</li>
<li><p>单链表的存储结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br><span class="line"><span class="comment">//LinkList与Node*同为指针类型的变量，这两种类型是等价的</span></span><br><span class="line"><span class="comment">//用LinkList指向头指针，Node*指向结点</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>单链表的基本运算（细讲）</p>
<ul>
<li><p>初始化单链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList *L)</span><span class="comment">//L是指向单链表的头结点的指针</span></span><br><span class="line">&#123;</span><br><span class="line">    *L=(LinkList)mallco(sizeOf(Node));</span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立单链表:</p>
<ol>
<li><p>头插法建立单链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateFromHead</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        c=getchar();</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27;$&#x27;</span>)   <span class="comment">//$是终止符</span></span><br><span class="line">        &#123;</span><br><span class="line">            s=(Node*)mallco(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            s-&gt;data=c;</span><br><span class="line">            s-&gt;next=L-&gt;next;</span><br><span class="line">            L-&gt;next=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法建立链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">void</span> <span class="title function_">CreateFromTail</span><span class="params">(LinkList L)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Node *r,*s;</span><br><span class="line">         <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         r=L;</span><br><span class="line">         <span class="keyword">while</span>(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             c=getchar();</span><br><span class="line">             <span class="keyword">if</span>(c!=<span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 s=(Node*)mallco(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">                 s-&gt;data=c;</span><br><span class="line">                 r-&gt;next=s;</span><br><span class="line">                 r=s;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 flag=<span class="number">0</span>;</span><br><span class="line">                 r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 查找</span><br><span class="line"></span><br><span class="line">  <span class="number">1.</span> 按序号查找:</span><br><span class="line"></span><br><span class="line">     若找到，返回该结点的位置，若没有找到，则返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">     ```c</span><br><span class="line">     Node* <span class="title function_">GetData</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">         Node *p;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">         p=L;</span><br><span class="line">         <span class="keyword">while</span>((p-&gt;next!=<span class="literal">NULL</span>)&amp;&amp;(j&lt;i))</span><br><span class="line">         &#123;</span><br><span class="line">             p=p-&gt;next;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i==j)</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按值查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">Locate</span><span class="params">(LinkList L,ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data!=key)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个算法的平均时间复杂度&#x3D;O(n)</p>
</li>
</ol>
</li>
<li><p>求单链表的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度O(n)</p>
</li>
<li><p>单链表的插入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsList</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *pre,*s;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    pre=L;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>&amp;&amp;k&lt;i<span class="number">-1</span>)    <span class="comment">//*</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    s=(Node*)mallco(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=pre-&gt;next;</span><br><span class="line">    pre-&gt;next=s;</span><br><span class="line">    retuen OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的删除操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelList</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line"><span class="comment">//删除第i个元素，并将删除的元素保存到变量*e当中</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *pre ,*r;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    pre=L;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next!=<span class="literal">NULL</span>&amp;&amp;k&lt;i<span class="number">-1</span>)     <span class="comment">//*注意与插入不同之处,确保pre-&gt;next有元素，避免出现空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;<span class="comment">//p是第i-1个</span></span><br><span class="line">    <span class="keyword">if</span>(pre-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    r=pre-&gt;next;</span><br><span class="line">    pre-&gt;next=r-&gt;next;</span><br><span class="line">    *e=r-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(r);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两个单链表:</p>
<p>有两个单链表，元素都是非递减有序排列，合并成单链表c也是非递减有序排列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">MergeLinkList</span><span class="params">(LinkList LA,LinkList LB)</span>  <span class="comment">//这里的两个变量都是头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *pa,*pb;</span><br><span class="line">    LinkList LC,r;</span><br><span class="line">    pa=LA-&gt;next;</span><br><span class="line">    pb=LB-&gt;next;</span><br><span class="line">    LC=LA;</span><br><span class="line">    LC-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r=LC;  <span class="comment">//r初始值为LC，且始终指向LC的表尾</span></span><br><span class="line">    <span class="keyword">while</span>(pa!=<span class="literal">NULL</span>&amp;&amp;pb!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=pa;</span><br><span class="line">            r=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next=pb;</span><br><span class="line">            r=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(pa!=<span class="literal">NULL</span>)</span><br><span class="line">            r-&gt;next=pa;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r-&gt;next=pb; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/2.png" style="zoom:10%;" /></li>
</ul>
</li>
</ol>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ol>
<li><p>定义方法：将单链表的最后一个结点的指针域，由指向NULL改为指向头结点</p>
</li>
<li><p>判断当前结点p是否是尾结点<code>p!=L</code>或<code>p-&gt;next!=L</code></p>
</li>
<li><p>分类：带头结点和带尾指针rear</p>
</li>
<li><p>初始化(带头结点)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCLinkList</span><span class="params">(LinkList *CL)</span></span><br><span class="line">&#123;</span><br><span class="line">    *CL=(LinkList)mallo(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*CL)-&gt;next=*CL;<span class="comment">//建立空的循环单链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立循环单链表:</p>
<p>假设已经进行了初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateCLinkList</span><span class="params">(LinkList CL)</span><span class="comment">//CL是头指针</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *rear,*s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    rear=CL;</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(Node*)mallco(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        s-&gt;data=c;</span><br><span class="line">        rear-&gt;next=s;</span><br><span class="line">        rear=s;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next=CL;<span class="comment">//循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两个循环列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LA表示头指针</span></span><br><span class="line">LinkList <span class="title function_">merge_CLists</span><span class="params">(LinkList LA,LinkList LB)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=LA;</span><br><span class="line">    q=LB;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=LA)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next!=LB)</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">    q-&gt;next=LA;       <span class="comment">//LB的尾连接到LA的头</span></span><br><span class="line">    p-&gt;next=LB-&gt;next; <span class="comment">//LA的尾连接到LB的头</span></span><br><span class="line">    <span class="built_in">free</span>(LB);</span><br><span class="line">    <span class="keyword">return</span> LA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LA表示尾指针</span></span><br><span class="line">LinkList <span class="title function_">merge_CLists</span><span class="params">(LinkList LA,LInkList LB)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=LA-&gt;next;  <span class="comment">//LA的头</span></span><br><span class="line">    LA-&gt;next=LB-&gt;next-&gt;next; <span class="comment">//LA的头连接到LB的尾</span></span><br><span class="line">    <span class="built_in">free</span>(LB-&gt;next);<span class="comment">//释放LB的头结点</span></span><br><span class="line">    LB-&gt;next=p;<span class="comment">//将LA的头结点接连到LB的尾部</span></span><br><span class="line">    <span class="keyword">return</span> LB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ol>
<li><p>结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    sruct DNode *prior,*next;</span><br><span class="line">&#125;DNode,*DoubleList;</span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/3.png" style="zoom:50%;" />
</li>
<li><p><code>p-&gt;prior-&gt;next==p==p-&gt;next-&gt;prior</code></p>
</li>
<li><p>插入操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DlinkIns</span><span class="params">(DoubleList L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    DNode *s,*p;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;k&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> intERROR;</span><br><span class="line">    s=(DNode*)mallkco(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data=e;</span><br><span class="line">        s-&gt;prior=p-&gt;prior;</span><br><span class="line">        p-&gt;prior-&gt;next=s;</span><br><span class="line">        s-&gt;next=p;</span><br><span class="line">        p-&gt;prior=s;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/4.jpg" style="zoom:20%;" />
</li>
<li><p>双向链表的删除操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DLinkDel</span><span class="params">(DoubleList L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    DNode *p;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;k&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/5.png" style="zoom:40%;" />
</li>
<li><p>静态链表</p>
</li>
</ol>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><h5 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h5><ol>
<li><p>表示：p[i]表示i次幂的系数</p>
</li>
<li><p>储存：</p>
<ul>
<li><p>顺序储存：p[i]表示i次幂的系数</p>
</li>
<li><p>链式存储：</p>
<ol>
<li><p>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Polynode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> coef;   <span class="comment">//系数</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;    <span class="comment">//指数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Polynode</span> *<span class="title">next</span>;</span><span class="comment">//指针</span></span><br><span class="line">&#125;Polynode,*Polylist;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法创建链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Polylist <span class="title function_">PolyCreate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynode *head,*rear;</span><br><span class="line">    <span class="type">int</span> coef,<span class="built_in">exp</span>;</span><br><span class="line">    head=(Polynode*)mallco(<span class="keyword">sizeof</span>(Polynode));</span><br><span class="line">    rear=head;   <span class="comment">//rear始终指向尾结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;coef,&amp;<span class="built_in">exp</span>);</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(Polynode*)mallco(<span class="keyword">sizeof</span>(Polynode));</span><br><span class="line">        s-&gt;coef=coef;</span><br><span class="line">        s-&gt;<span class="built_in">exp</span>=<span class="built_in">exp</span>;</span><br><span class="line">        rear-&gt;next=s;</span><br><span class="line">        rear=s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;coef,&amp;<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>一元多项式相加运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PolyAdd</span><span class="params">(Polylist polya,Polylist polyb)</span></span><br><span class="line">&#123;</span><br><span class="line">    Polynode *p,*q,*tail,*temp;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    p=polya-&gt;next;</span><br><span class="line">    q=polyb-&gt;next;</span><br><span class="line">    tail=polya;     <span class="comment">//tail是一个始终指向最终表的尾部的指针</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;<span class="built_in">exp</span>&lt;q-&gt;<span class="built_in">exp</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next=p;</span><br><span class="line">            tail=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;<span class="built_in">exp</span>==q-&gt;<span class="built_in">exp</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum==p-&gt;coef+q-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span>(sum!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;coef=sum;</span><br><span class="line">                tail-&gt;next=p;</span><br><span class="line">                tail=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                temp=q;</span><br><span class="line">                q=q-&gt;next;        <span class="comment">//都是先传到后面一个以后再free</span></span><br><span class="line">                <span class="built_in">free</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=q;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(temp);</span><br><span class="line">                temp=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">             tail-&gt;next=q;</span><br><span class="line">             tail=q;</span><br><span class="line">             q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        tail-&gt;next=p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tail-&gt;next=q;</span><br><span class="line">    <span class="built_in">free</span>(polyb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="顺序表删除指定元素"><a href="#顺序表删除指定元素" class="headerlink" title="顺序表删除指定元素"></a>顺序表删除指定元素</h5><ul>
<li>删除所有x</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delx</span><span class="params">(SeqList *L,ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=L-&gt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;elem[i]!=x)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;elem[j]=L-&gt;elem[i];</span><br><span class="line">            i++,j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;last=j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单链表的就地逆置"><a href="#单链表的就地逆置" class="headerlink" title="单链表的就地逆置"></a>单链表的就地逆置</h5><ul>
<li>逻辑：读取后一位并用头插法插入</li>
<li>图解： <img src="/images/blog_images/Basic_Algorithms/6.jpg" style="zoom:50%;" /></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReverseeList</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        p-&gt;next=L-&gt;next;  <span class="comment">// 1</span></span><br><span class="line">        L-&gt;next=p;       <span class="comment">// 2</span></span><br><span class="line">        p=q;         <span class="comment">// 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单链表的部分快排"><a href="#单链表的部分快排" class="headerlink" title="单链表的部分快排"></a>单链表的部分快排</h5><ul>
<li>读取第一个数据data，后续比它大的放在该结点的前面，比它小的放在后面</li>
<li>逻辑：比它小的结点头插，比它大的不管</li>
<li>图解：见逆置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vod <span class="title function_">changelist</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *a,*p,*q;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    a=L-&gt;next;</span><br><span class="line">    p=a-&gt;next;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;=a-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            p=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=L-&gt;next;</span><br><span class="line">            L-&gt;next=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单链表二进制加一"><a href="#单链表二进制加一" class="headerlink" title="单链表二进制加一"></a>单链表二进制加一</h5><ul>
<li>建表：第一个结点存储二进制数的最高位，依次存储，最后一个结点存储最低位。</li>
<li>实现加1运算：从最低位往前，找到第一个0的位次所在结点，变成1；从该结点向后，所有的1都变成0，</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinAdd</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p,*goal,*s;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    r=L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==<span class="number">0</span>)   <span class="comment">//找到最后一个为0的位置</span></span><br><span class="line">            r=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r!=L)</span><br><span class="line">        r-&gt;data=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(Node*)mallco(<span class="keyword">sizeof</span>(Node));  <span class="comment">//申请新结点存放最高进位</span></span><br><span class="line">        s-&gt;data=<span class="number">1</span>;   <span class="comment">//赋值为1</span></span><br><span class="line">        s-&gt;next=L-&gt;next;    <span class="comment">//将新结点头插入</span></span><br><span class="line">        L-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r=r-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(r!=<span class="literal">NULL</span>)    <span class="comment">//将后面的所有结点赋值为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;data=<span class="number">0</span>;</span><br><span class="line">        r=r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三章：限定性线性表——栈与队列"><a href="#第三章：限定性线性表——栈与队列" class="headerlink" title="第三章：限定性线性表——栈与队列"></a>第三章：限定性线性表——栈与队列</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><ol>
<li><p>存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Stack_Size 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    StackElementType elem[Stack_Size];</span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">//存放栈顶元素的下标，top=-1为空栈</span></span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本操作：</p>
<p><code>#define TRUE 1;</code></p>
<p><code>#define FALSE 0;</code></p>
<ul>
<li><p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SeqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(SeqStack *S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top==Stack_Size<span class="number">-1</span> ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SeqStack *S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top==<span class="number">-1</span> ? TRUE : FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>进栈和出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(SeqStack *S,StackElementType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(S))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    S-&gt;top++;</span><br><span class="line">    S-&gt;elem[S-&gt;top]=x;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(SeqStack *S,StackElementType *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *x=S-&gt;elem[S-&gt;top];</span><br><span class="line">        S-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两栈共享技术</p>
<img src="/images/blog_images/Basic_Algorithms/7.png" style="zoom:32%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType Stack[M];</span><br><span class="line">    StackElementType top[<span class="number">2</span>];</span><br><span class="line">&#125;DqStack;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(DqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;top[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    S-&gt;top[<span class="number">1</span>]=M;   <span class="comment">//表示空栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><ol>
<li><p>结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStackNode,*LinkStack;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>始终有一个栈顶指针top,指向当前栈顶元素的头结点</strong></li>
<li>若<code>top-&gt;next==NULL</code>，则栈空</li>
<li>链栈不会溢出</li>
</ul>
</li>
<li><p>栈操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(LinkStack top,StackElementType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//头插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack top,StackElementType *x)</span><span class="comment">//取头元素</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkStackNode *temp;</span><br><span class="line">    temp=top-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    top-&gt;next=temp-&gt;next;</span><br><span class="line">    *x=temp-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(LinkStack S,StackElementType *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *x=S-&gt;elem[S-&gt;top];</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>多栈运算</p>
<p>将多个链栈的栈顶指针放在一个一维数组里面来统一管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStackNode,*LinkStack;</span><br><span class="line">LinkStack top[M];</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h4><ul>
<li><p>逻辑：用栈读入每一个字符。如果是左括号就直接入栈；如果是右括号，且与当前左括号匹配，则将左括号出栈，不匹配则不符合要求；最终读完要求栈为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Match</span><span class="params">(<span class="type">char</span> ch,<span class="type">char</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    reurn ch==temp ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BracketMatch</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack *S;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                Push(S,str[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:<span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">                &#123;</span><br><span class="line">                    pritnf(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    GetTop(S,&amp;ch);  <span class="comment">//读取栈顶的左括号</span></span><br><span class="line">                    <span class="keyword">if</span>(Match(ch,str[i]))  <span class="comment">//比较是否匹配</span></span><br><span class="line">                        Pop(S,&amp;ch);    <span class="comment">//如果匹配，则出栈</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="表达式求值-无括号"><a href="#表达式求值-无括号" class="headerlink" title="表达式求值(无括号)"></a>表达式求值(无括号)</h4><ul>
<li>考虑因素：</li>
</ul>
<ol>
<li>从左至右依次读取数和运算符</li>
<li>运算符的优先级</li>
<li>特殊运算符：^为幂运算，#是表达式结束符</li>
</ol>
<ul>
<li><p>算法逻辑：</p>
<ol>
<li>规定运算符的优先级表</li>
<li>设置两个栈：OVS运算数栈，OPTR运算符栈</li>
<li>从左至右读入，<ul>
<li>遇到运算数：进入运算数栈</li>
<li>遇到运算符，比较优先级<ol>
<li>当前运算符&gt;OPTR栈顶运算符，则当前运算符进栈</li>
<li>当前运算符&lt;&#x3D;OPTR栈顶运算符，则OPTR出栈一次，得到运算符$；OVS出栈两次，得到运算数a,b；进行运算后得到数t,将t入栈</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>图解：</p>
</li>
<li><img src="/images/blog_images/Basic_Algorithms/8.jpg" style="zoom:20%;" />
</li>
<li><pre><code class="c">int ExpEvaluation()
&#123;
    SeqStack OPTR,OVS;
    char n,a,b,v;
    char ch,op;
    InitStack(&amp;OPTR);     //1
    InitStack(&amp;OVS);
    Push(&amp;OPTR,&#39;#&#39;);     //push(OPTR)2
    printf(&quot;input an expression(Ending with =):&quot;);
    ch=getchar();
    while(ch!=&#39;#&#39;||GetTop(&amp;OPTR)!=&#39;#&#39;)  //3
    &#123;
        if(!In(ch,OPSet))   //4
        &#123;
            n=GetNumber(ch);   //5
            Push(&amp;OVS,n);     //6
            ch=getchar();
        &#125;
        else
            switch(Compare(ch,GetTop(&amp;OPTR)))  //7
            &#123;
                case  &#39;&gt;&#39;:
                    Push(&amp;OPTR,ch);
                    ch=getchar();
                    break;
                case &#39;=&#39;:
                case &#39;&lt;&#39;:
                    Pop(&amp;OPTR,&amp;op);        //8
                    Pop(&amp;OVS,&amp;a);
                    Pop(&amp;OVS,&amp;b);
                    v=Execute(a,op,b);        //9
                    Push(&amp;OVS,v);
                    break;
            &#125;
    &#125;
    v=GetTop(&amp;OVS);
    return v;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  注意c语言里面的int和char 类型的相似性</span><br><span class="line">  </span><br><span class="line">  [完整代码]: D:\Alearning\c2.0\dataStructuresInC\textbook\Stack\new.c</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 表达式求值（含括号）</span><br><span class="line"></span><br><span class="line">- 基本逻辑与无括号相似，主要区别是优先级处理和循环结构</span><br><span class="line"></span><br><span class="line">#### 栈与递归的实现</span><br><span class="line"></span><br><span class="line">### 队列</span><br><span class="line"></span><br><span class="line">1. 结构：两个指针，一个指向队头，一个指向队尾</span><br><span class="line"></span><br><span class="line">   ```c </span><br><span class="line">   typedef struct Node</span><br><span class="line">   &#123;</span><br><span class="line">       QueueElementType data;</span><br><span class="line">       struct Node *next;</span><br><span class="line">   &#125;LinkQueueNode;</span><br><span class="line">   typedef struct</span><br><span class="line">   &#123;</span><br><span class="line">       LinkQueueNode *front;</span><br><span class="line">       LinkQueueNode *rear;</span><br><span class="line">   &#125;LinkQueue;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<ol start="2">
<li><p>基本操作：</p>
<ul>
<li><p>链队列初始化:注意第一个结点不存数据</p>
<img src="/images/blog_images/Basic_Algorithms/9.jpg" style="zoom:13%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front=(LinkQueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueueNode));</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear=Q-&gt;front;</span><br><span class="line">        Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队操作:只能在队尾加入结点</p>
<img src="/images/blog_images/Basic_Algorithms/10.jpg" style="zoom:16%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">EnterQueue</span><span class="params">(LinkQueue *Q,QueueElementType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueueNode *newNode;</span><br><span class="line">    newNode=(LinkQueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueueNode));</span><br><span class="line">    <span class="keyword">if</span>(newNode!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newNode-&gt;data=x;</span><br><span class="line">        newNode-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//(1)</span></span><br><span class="line">        Q-&gt;rear-&gt;next=newNode;   <span class="comment">//(2)</span></span><br><span class="line">        Q-&gt;rear=newNode;       <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    retunr FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队操作：</p>
<img src="/images/blog_images/Basic_Algorithms/11.jpg" style="zoom:19%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DeleteQueue</span><span class="params">(LinkQueue *Q,QueueElementType *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueueNode *p;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    p=Q-&gt;front-&gt;next;     <span class="comment">//(1)</span></span><br><span class="line">    Q-&gt;front-&gt;next=p-&gt;next;   <span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear==p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear=Q-&gt;front;</span><br><span class="line">    &#125;</span><br><span class="line">    *x=p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ol>
<li><p>要点：</p>
<ol>
<li>用数组存储数据，并且将他看作是一个环状的空间</li>
<li>规定最后一个单元的后继为第一个单元，即<code>Queue[MAXSIZE-1]</code>的下一个是<code>Queue[0]</code></li>
<li>实现方法：尾指针<code>rear=(rear+1)%MAXSIZE</code>,头指针<code>front=(front+1)%MAXSIZE</code></li>
</ol>
</li>
<li><p>储存方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueueElementType element[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SeqQueue; </span><br></pre></td></tr></table></figure>
</li>
<li><p>基本操作</p>
<ul>
<li><p>初始化:空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SeqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的入队操作（放入尾部）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">EnterQueue</span><span class="params">(SeqQueue *Q,QueueElementType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)   <span class="comment">//尾指针追上头指针，已满</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    Q-&gt;element[Q-&gt;rear+<span class="number">1</span>]=x;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环列表的出队操作(删除头元素)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DeleteQueue</span><span class="params">(SeqQueue *Q,QueueElementType *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    *x=Q-&gt;element[Q-&gt;front];</span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种处理假溢出的方法：添加一个标志量tag</p>
</li>
</ul>
</li>
</ol>
<h4 id="应用（自学）"><a href="#应用（自学）" class="headerlink" title="应用（自学）"></a>应用（自学）</h4><ol>
<li><p>打印杨辉三角</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">YangHuiTriangle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    EnterQueue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n,i,temp,x;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">2</span>;n&lt;=N;n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        EnterQueue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            DeleteQueue(&amp;Q,&amp;temp);<span class="comment">//取出当前第一位，并将front移动到原来的第二，并赋值给temp</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp);</span><br><span class="line">            GetHead(Q,&amp;x);  <span class="comment">//得到当前的第一位，即原来的第二位</span></span><br><span class="line">            temp=temp+x;  <span class="comment">//第一+第二</span></span><br><span class="line">            EnterQueue(&amp;Q,temp);  <span class="comment">//将新的存入尾部</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一行最后一个元素和上一行一样都是1</span></span><br><span class="line">        DeleteQueue(&amp;Q,&amp;x);<span class="comment">//目的有，使front移动至新的一行的开头</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">        EnterQueue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteQueue(&amp;Q,&amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>键盘缓冲区</p>
</li>
</ol>
<h2 id="第四章：串"><a href="#第四章：串" class="headerlink" title="第四章：串"></a>第四章：串</h2><h3 id="串的存储实现"><a href="#串的存储实现" class="headerlink" title="串的存储实现"></a>串的存储实现</h3><h4 id="定长顺序串"><a href="#定长顺序串" class="headerlink" title="定长顺序串"></a>定长顺序串</h4><ol>
<li><p>存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 40</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本操作</p>
<ul>
<li><p>顺序插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrInsert</span><span class="params">(Sstring *s,<span class="type">int</span> pos,SString t)</span></span><br><span class="line">    <span class="comment">//在串s中的下标为pos的字符之前插入串t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;s-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;len+t.len&lt;=MAXLEN)<span class="comment">//插入后总长小于MAXLEN</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=s-&gt;len+t.len<span class="number">-1</span>;i&gt;=t.len+pos;i--)</span><br><span class="line">            s-&gt;ch[i]=s-&gt;ch[i-t.len];<span class="comment">//将pos位置以后的元素一次向后移动t.len个位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t.len;i++)</span><br><span class="line">            s-&gt;ch[i+pos]=t.ch[i];</span><br><span class="line">        s-&gt;len=s-&gt;len+t.len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos+t.len&lt;=MAXLEN)<span class="comment">//t可以完全插入，但是总长超过了MAXLEN</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=MAXLEN<span class="number">-1</span>;i&gt;t.len+pos<span class="number">-1</span>;i--)</span><br><span class="line">            s-&gt;ch[i]=s-&gt;ch[i-t.len];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t.len;i++)</span><br><span class="line">            s-&gt;ch[i+pos]=t.ch[i];</span><br><span class="line">        s-&gt;len=MAXLEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//t不能完全装下</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXLEN-pos;i++)</span><br><span class="line">            s-&gt;ch[i+pos]=t.ch[i];</span><br><span class="line">        s-&gt;len=MAXLEN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>串删除函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrDelete</span><span class="params">(SString *s,<span class="type">int</span> pos,<span class="type">int</span> len)</span></span><br><span class="line">    <span class="comment">//在串s中删除从下标pos起len个字符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;(s-&gt;len-len))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">for</span>(i=pos+len;i&lt;s-&gt;len;i++)</span><br><span class="line">        s-&gt;ch[i-len]=s-&gt;ch[i];</span><br><span class="line">    s-&gt;len=s-&gt;len-len;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>串比较函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString s,SString t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.len&amp;&amp;i&lt;t.len;i++)</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]!=t.ch[i])</span><br><span class="line">            <span class="keyword">return</span> s.ch[i]-t.ch[i];</span><br><span class="line">    <span class="keyword">return</span> s.len-t.len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>串的简单模式匹配算法</p>
<p>匹配模式：在主串S中寻找子串T的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrIndex</span><span class="params">(SString s,<span class="type">int</span> pos,SString t)</span><span class="comment">//从主串下标为pos的地方开始寻找</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,start;</span><br><span class="line">    <span class="keyword">if</span>(t.len==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    start=pos;</span><br><span class="line">    i=start;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.len&amp;&amp;j&lt;t.len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==t.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start++;</span><br><span class="line">            i=start;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j=t.len)</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMP算法</p>
<p>简介：</p>
<ol>
<li><p>将目标匹配串的前缀表列出，即每个子串，按从左至右顺序的最大的重复部分的字符数量，例如：<img src="/images/blog_images/Basic_Algorithms/12.jpg" style="zoom:33%;" /></p>
</li>
<li><p>并将其用数组next的形式与子串的每一个字符一一对应起来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Profix_table</span><span class="params">(SString t,<span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j,k;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    k=<span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;t-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span>||t-&gt;data[j]==t-&gt;data[k])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            next[j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k=next[k];  <span class="comment">//****</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前缀表的作用是遇到不能匹配的字符的时候，将它前面的能匹配的字符串的最大相似部分跳过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrIndex_KMP</span><span class="params">(SString s,<span class="type">int</span> pos ,SString t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(t.len==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    i=pos;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.len&amp;&amp;j&lt;t.len)</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s.ch[i]==t.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j=next[j];   <span class="comment">//***</span></span><br><span class="line">    <span class="keyword">if</span>(j&gt;=t.len)</span><br><span class="line">        <span class="keyword">return</span> i-t.len;<span class="comment">//成功返回主串的当前起始匹配位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不成功返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="堆串"><a href="#堆串" class="headerlink" title="堆串"></a>堆串</h3><ol>
<li><p>结构</p>
<img src="/images/blog_images/Basic_Algorithms/13.jpg" style="zoom:15%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;Hstring;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本操作</p>
<ul>
<li>堆串插入函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrInsert</span><span class="params">(HString *s,<span class="type">int</span> pos,HString *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *temp;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;s-&gt;len||s-&gt;len==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    temp=(<span class="type">char</span>*)<span class="built_in">malloc</span>(s-&gt;len+t-&gt;len);</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pos;i++)</span><br><span class="line">        temp[i]=s-&gt;ch[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t-&gt;len;i++)</span><br><span class="line">        temp[i+pos]=t-&gt;ch[i];</span><br><span class="line">    <span class="keyword">for</span>(i=pos;i&lt;s-&gt;len;i++)</span><br><span class="line">        temp[i+t-&gt;len]=s-&gt;ch[i];</span><br><span class="line">    s-&gt;len+=t-&gt;len;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;ch);</span><br><span class="line">    s-&gt;ch=temp;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>堆串赋值函数()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrAssign</span><span class="params">(HString *s,<span class="type">char</span> *tval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;ch!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;ch);</span><br><span class="line">    <span class="keyword">while</span>(tval[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        i++;</span><br><span class="line">    len=i;</span><br><span class="line">    <span class="keyword">if</span>(len)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;ch=(<span class="type">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;ch==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            s-&gt;ch[i]=tval[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s-&gt;ch=<span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;len=len;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="块链串"><a href="#块链串" class="headerlink" title="块链串"></a>块链串</h3><ol>
<li><p>结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[BLOCK_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BLOCK</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Block;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BLString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Block *head;</span><br><span class="line">    Block *tail;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;BLString;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;存储密度&#x3D;ch[]&#x2F;(ch[]+指针域所占字节数)</p>
</li>
</ol>
<h2 id="第五章：数组与广义表"><a href="#第五章：数组与广义表" class="headerlink" title="第五章：数组与广义表"></a>第五章：数组与广义表</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>可以把二位数组看作一个线性表，就相当于矩阵</li>
<li>这里的数组下标统一从1开始：</li>
</ol>
<h3 id="特殊矩阵的压缩存储（重点）"><a href="#特殊矩阵的压缩存储（重点）" class="headerlink" title="特殊矩阵的压缩存储（重点）"></a>特殊矩阵的压缩存储（重点）</h3><ol>
<li>地址计算P129<ul>
<li>一维数组的地址计算：<code>Loc(A[i])=Loc(A[1])+(i-1)*size</code></li>
<li>二维数组的地址计算：<code>Loc(A[i][j])=Loc(A[1][1])+((i-1)*n+(j-1))*size</code></li>
<li>三维数组的地址计算：<code>Loc(A[i][j][k])=Loc(A[1][1][1])+((i-1)*n*m+(j-1)*n+(k-1))*size</code></li>
<li>以此类推</li>
</ul>
</li>
</ol>
<h3 id="规律分布的特殊矩阵"><a href="#规律分布的特殊矩阵" class="headerlink" title="规律分布的特殊矩阵"></a>规律分布的特殊矩阵</h3><ol>
<li><p>三角矩阵：</p>
<ul>
<li><img src="/images/blog_images/Basic_Algorithms/14.png" style="zoom:20%;" />
</li>
<li><p>上三角矩阵：i&lt;j时，Aij&#x3D;0</p>
<p>存储地址：<code>Loc[i,j]=Loc[1,1]+(i*(i-1)/2+j-1)</code></p>
</li>
<li><p>下三角矩阵：i&gt;j时，Aij&#x3D;0</p>
</li>
</ul>
</li>
<li><p>带状矩阵：</p>
<ul>
<li>三对角带状矩阵<img src="/images/blog_images/Basic_Algorithms/15.png" style="zoom:50%;" /></li>
<li>存储地址：<code>Loc(A[i][j])=Loc(A[1][1])+(3*(i-1)-1+(j-i+1))*size</code></li>
</ul>
</li>
<li><p>稀疏矩阵：指矩阵中绝大多数元素为0的矩阵</p>
<ul>
<li><p>稀疏矩阵的三元组表示法：</p>
<ol>
<li><p>基本类型结构：行、列、值。相当于只存储了非零元素的位置和值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> row,col;<span class="comment">//该非零元素的行列下标</span></span><br><span class="line">    ElementType e;<span class="comment">//该非零元素的值</span></span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Triple data[MAXSIZE+<span class="number">1</span>];<span class="comment">//非零元素的三元组表，data[0]未用</span></span><br><span class="line">    <span class="type">int</span> m,n,len;   <span class="comment">//m是行数，n是列数，len是元素总个数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵的经典转置运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TransMatrix</span><span class="params">(ElementType source[m][n],ElementType dest[n][m])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            dest[j][i]=source[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用三元组表实现稀疏矩阵的转置</p>
<p>先将原三元组表的行列互换，然后将互换后的三元组表，按照行下标的大小以递增顺序排列</p>
<ul>
<li><p>方法一：列序递增转置方法（双重循环）:</p>
<p>·按照被转置矩阵三元组表A的列序（即转置后三元组表 B的行序）递增的顺序进行转置，并依次送入转置后矩阵的三元组表B中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TransTSMatrix</span><span class="params">(TSMatrix A,TSMatrix *B)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    B-&gt;m=A.n;</span><br><span class="line">    B-&gt;n=A.m;</span><br><span class="line">    B-&gt;len=A.len;</span><br><span class="line">    <span class="keyword">if</span>(B-&gt;len&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="number">1</span>;<span class="comment">//辅助计数器，记录转置后的元素在三元组表B中的下标值</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=A.n;k++)</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=A.len;i++)</span><br><span class="line">                <span class="keyword">if</span>(A.data[i].col=k)</span><br><span class="line">                &#123;</span><br><span class="line">                    B-&gt;data[j].row=A.data[i].col;</span><br><span class="line">                    B-&gt;data[j].col=A.data[i].row;</span><br><span class="line">                    B-&gt;data[j].e=A.data[i].e;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：一次定位快速转置法：</p>
<ol>
<li>设置两个数组<ul>
<li><code>num[col]</code>:存放三元组表A中的第col列非零元素的个数</li>
<li><code>position[col]</code>:存放转置前三元组表A中第col列中第一个非零元素在三元组表B中的存储位置</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FastTransTSMatrix</span><span class="params">(TSMatrix A,TSMatrix *B)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> col,t,p,q;</span><br><span class="line">    <span class="type">int</span> num[MAXSIZE],position[MAXSIZE];</span><br><span class="line">    B-&gt;len=A.len;</span><br><span class="line">    B-&gt;n=A.m;</span><br><span class="line">    B-&gt;m=A.n;</span><br><span class="line">    <span class="keyword">if</span>(B-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col=<span class="number">1</span>;col&lt;=A.n;col++)</span><br><span class="line">            num[col]=<span class="number">0</span>;   <span class="comment">//初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;=A.len;t++)</span><br><span class="line">            num[A.data[t].col]++;  <span class="comment">//统计每一列的非零元素的个数</span></span><br><span class="line">        position[<span class="number">1</span>]=<span class="number">1</span>;  <span class="comment">//第一列的非零元素的存储位置是1</span></span><br><span class="line">        <span class="keyword">for</span>(col=<span class="number">2</span>;col&lt;=A.n)</span><br><span class="line">            position[col]=position[col<span class="number">-1</span>]+num[col<span class="number">-1</span>]; <span class="comment">//第col列中第一个非零元素在B.data[]中的正确位置</span></span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">1</span>;p&lt;=A.len;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col=A.data[p].col;</span><br><span class="line">            q=position[col];<span class="comment">//找到第col列第一个非零元素的正确位置</span></span><br><span class="line">            B-&gt;data[q].row=A.data[p].col;</span><br><span class="line">            B-&gt;data[q].col=A.data[p].row;</span><br><span class="line">            B-&gt;data[q].e=A.data[p].e;</span><br><span class="line">            position[col]++;    <span class="comment">//指向第col列下一个非零元素的正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>稀疏矩阵的链式存储结构：十字链表</p>
<ol>
<li><p>结构：每一个非零元素用一个结点表示，该节点除了(row,col,value)以外，还有两个链域</p>
</li>
<li><p>类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> row,col;</span><br><span class="line">    ElementType value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>;</span>   <span class="comment">//用于连接同一行中的下一个非零元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">down</span>;</span>    <span class="comment">//用于连接同一列中的下一个非零元素</span></span><br><span class="line">&#125;OLNode,*OLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OLink *row_head,*col_head; <span class="comment">//行、列链表的头指针向量</span></span><br><span class="line">    <span class="type">int</span> m,n,len;         <span class="comment">//稀疏矩阵的行数、列数、非零元素的个数</span></span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/16.jpg" style="zoom:67%;" />
</li>
<li><p>十字链表的算法实现：</p>
<ul>
<li><p>建立十字链表的步骤：</p>
<ol>
<li>读入稀疏矩阵的行数列数和非零元素个数</li>
<li>动态申请行、列链表的头指针向量</li>
<li>逐个读入非零元素，分别插入行、列链表</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList</span><span class="params">(CrossList *M)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,n,len,i,j;</span><br><span class="line">    ElementType e;</span><br><span class="line">    OLink p,q;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入行数，列数，非零元素个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;m,&amp;n,&amp;len);</span><br><span class="line">    M-&gt;m=m;</span><br><span class="line">    M-&gt;n=n;</span><br><span class="line">    M-&gt;len=len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(M-&gt;row_head=(OLink*)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink))))</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="keyword">if</span>(!(M-&gt;col_head=(OLink*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(OLink))))</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="comment">//初始化行、列的头指针向量，使各行、列链表为空</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        M-&gt;row_head[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        M-&gt;col_head[j]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//循环读入行、列、值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(&amp;i,&amp;j,&amp;e);i!=<span class="number">-1</span>;<span class="built_in">scanf</span>(&amp;i,&amp;j,&amp;e))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建结点</span></span><br><span class="line">        <span class="keyword">if</span>(!p=(OLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode)))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        p-&gt;row=i;</span><br><span class="line">        p-&gt;col=j;</span><br><span class="line">        p-&gt;value=e;</span><br><span class="line">        <span class="comment">//先考虑行</span></span><br><span class="line">        <span class="comment">//如果所在行为空</span></span><br><span class="line">        <span class="keyword">if</span>(M-&gt;row_head[i]==<span class="literal">NULL</span>)</span><br><span class="line">            M-&gt;row_head[i]=p;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=M-&gt;row_head[i];</span><br><span class="line">            <span class="comment">//寻找插入的位置</span></span><br><span class="line">            <span class="keyword">while</span>(q-&gt;right!=<span class="literal">NULL</span>&amp;&amp;q-&gt;right-&gt;col&lt;j)</span><br><span class="line">                q=q-&gt;right;</span><br><span class="line">            <span class="comment">//q-&gt;right是目标位置</span></span><br><span class="line">            p-&gt;right=q-&gt;right;</span><br><span class="line">            q-&gt;right=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同理，考虑列</span></span><br><span class="line">        <span class="keyword">if</span>(M-&gt;col_head[j]==<span class="literal">NULL</span>)</span><br><span class="line">            M-&gt;col_head[j]=p;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=M-&gt;col_head[i];</span><br><span class="line">            <span class="comment">//寻找插入的位置</span></span><br><span class="line">            <span class="keyword">while</span>(q-&gt;down!=<span class="literal">NULL</span>&amp;&amp;q-&gt;down-&gt;row&lt;j)</span><br><span class="line">                q=q-&gt;down;</span><br><span class="line">            <span class="comment">//q-&gt;down是目标位置</span></span><br><span class="line">            p-&gt;down=q-&gt;down;</span><br><span class="line">            q-&gt;down=p;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="第六章：树与二叉树"><a href="#第六章：树与二叉树" class="headerlink" title="第六章：树与二叉树"></a>第六章：树与二叉树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ol>
<li><p>关系：一对多，层次化</p>
</li>
<li><p>基本概念：</p>
<ul>
<li>根：没有前驱，有一个或者多个后继</li>
<li>子树：只有一个前驱，有一个或者多个后继，子树之间互不相交</li>
<li>结点的度：一个结点的子树个数    ； 树的度：树中所有结点的度的最大值</li>
<li>结点的层次：从根结点开始定义，根的层次为1 ，它的直接后继的层次为2，依次类推</li>
<li>树的高度（深度）：层次的最大值</li>
<li>结点的层序编号：将树中的结点按从上层到下层、同层从左到右的次序排成一个线性序列，依次给它们编以连续的自然数</li>
<li>结点之间的层次关系：<ul>
<li>双亲结点：结点的直接前驱</li>
<li>前辈,后辈：比较结点的层次</li>
</ul>
</li>
</ul>
</li>
<li><p>树的数据类型</p>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ol>
<li><p>定义：</p>
<ul>
<li>每个结点的度都不大于2；</li>
<li>每个结点的孩子结点次序都不能任意颠倒（左子树和右子树）</li>
</ul>
</li>
<li><p>性质：</p>
<ol>
<li><p>在二叉树的第i层上至多有2^(i-1)个结点</p>
</li>
<li><p>深度为k的二叉树至多有2^k-1个结点</p>
</li>
<li><p>任意一棵二叉树T，若终端节点(度数为0的结点)数为m，而其度数为2的节点数为n，则m&#x3D;n+1;</p>
</li>
<li><p>满二叉树：深度为k且有2^k-1个结点的二叉树</p>
</li>
<li><p>完全二叉树：深度为k，结点数为n，结点位置序号与相同高度的满二叉树一一对应</p>
<img src="/images/blog_images/Basic_Algorithms/17.jpg" style="zoom:50%;" />
</li>
<li><p>具有n个结点的完全二叉树的深度为(log2 n)+1</p>
</li>
</ol>
</li>
<li><p>存储结构：</p>
<ul>
<li><p>顺序存储</p>
</li>
<li><p>链式存储：</p>
<img src="/images/blog_images/Basic_Algorithms/18.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">RChild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ol>
<li><p>遍历（左右孩子和根的访问顺序）</p>
<ul>
<li><p>先序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Data-&gt;L-&gt;R</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        PreOrder(root-&gt;LChild);</span><br><span class="line">        PreOrder(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//L-&gt;Data-&gt;R</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(root-&gt;LChild);</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        InOrder(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//L-&gt;R-&gt;Data</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(root-&gt;LChild);</span><br><span class="line">        PostOrder(root-&gt;RChild);</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历算法的应用</p>
<ul>
<li><p>输出二叉树当中的叶子结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;RChild==<span class="literal">NULL</span>)</span><br><span class="line">            print(root-&gt;data);</span><br><span class="line">        PreOrder(root-&gt;LChild);</span><br><span class="line">        PreOrder(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计叶子结点的数目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：递归遍历统计</span></span><br><span class="line"><span class="type">int</span> LeafCount=<span class="number">0</span> ; <span class="comment">//全局变量，用于统计叶子结点的数目</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leaf</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(root)</span><br><span class="line">   &#123;</span><br><span class="line">        leaf(root-&gt;LChild);</span><br><span class="line">        leaf(root-&gt;RChild);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;RChild==<span class="literal">NULL</span>)</span><br><span class="line">            LeafCount++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：分治算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">leaf</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> LeafCnt;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//空树</span></span><br><span class="line">        LeafCnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>&amp;&amp;root-&gt;RChild==<span class="literal">NULL</span>)<span class="comment">//叶子结点</span></span><br><span class="line">        LeafCnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LeafCnt=leaf(root-&gt;LChild)+leaf(root-&gt;RChild);</span><br><span class="line">    <span class="keyword">return</span> LeafCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立二叉链表方式存储的二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *bi)</span><span class="comment">//这里传的是二级指针</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//假设data的类型是字符型</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        *bi=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *bi=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*bi)-&gt;data=ch;</span><br><span class="line">        CreateBiTree(&amp;((*bi)-&gt;LChild));</span><br><span class="line">        CreateBiTree(&amp;((*bi)-&gt;RChild));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求二叉树的高度</p>
<p>逻辑 ：高度就是二叉树的层次的最大值，或者说左右子树的高度最大值+1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分沿法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PostTreeDepth</span><span class="params">(BiTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hl,hr,max;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hl=PostTreeDepth(bt-&gt;LChild);</span><br><span class="line">        hr=PostTreeDepth(bt-&gt;RChild);</span><br><span class="line">        max=hl&gt;hr?hl:hr;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">int</span> depht=<span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTreeDepth</span><span class="params">(BiTree bt,<span class="type">int</span> h)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h&gt;depth)</span><br><span class="line">            depht=h;</span><br><span class="line">        PreTreeDepth(bt-&gt;LChild,h+<span class="number">1</span>);</span><br><span class="line">        PreTreeDepth(bt-&gt;RChild,h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按横向树形显示二叉树<img src="/images/blog_images/Basic_Algorithms/19.jpg" style="zoom:20%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintTree</span><span class="params">(BiTree bt,<span class="type">int</span> nLayer)</span>  <span class="comment">//实现先右后左</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nLayer;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,bt-&gt;data);</span><br><span class="line">    PrintTree(bt-&gt;RChild,nLayer+<span class="number">1</span>);</span><br><span class="line">    PrintTree(bt-&gt;LChild,nlayer+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>层次遍历法(<strong>不考</strong>)</p>
<img src="/images/blog_images/Basic_Algorithms/20.png" style="zoom:50%;" />

<img src="/images/blog_images/Basic_Algorithms/21.png" style="zoom:40%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree Queue[MAXNODE];  <span class="comment">//定义队列，队列先进先出</span></span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)    <span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    front=<span class="number">0</span>;</span><br><span class="line">    rear=<span class="number">0</span>;</span><br><span class="line">    Queue[rear]=bt;  <span class="comment">//根结点入队列</span></span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">while</span>(rear!=front)  <span class="comment">//队列不空，继续遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        visit(Queue[front]-&gt;data);  <span class="comment">//访问刚出队的元素</span></span><br><span class="line">        <span class="keyword">if</span>(Queue[front]-&gt;LChild!=<span class="literal">NULL</span>)  <span class="comment">//如果有左孩子，左孩子先入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            Queue[rear]=Queue[front]-&gt;LChild;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Queue[front]-&gt;RChild!=<span class="literal">NULL</span>)<span class="comment">//如果有右孩子，右孩子先后队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            Queue[rear]=Queue[front]-&gt;RChild;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;  <span class="comment">//出队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>基于栈的递归消除</p>
<ul>
<li><p><strong>中序</strong>遍历二叉树的非递归算法</p>
<p>注意：中序遍历法（非递归）需要设置一个堆栈，用于保留结点的指针，以便于在遍历完某个结点的左孩子树后，由该指针找到该结点的右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接实现栈操作</span></span><br><span class="line"><span class="comment">/*算法思想：从根结点开始，只要当前结点存在或者栈不空,循环：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 从当前结点开始，进栈并遍历左子树，直到左子树为空</span></span><br><span class="line"><span class="comment">2. 退栈并访问（栈先进后出）</span></span><br><span class="line"><span class="comment">3. 遍历右子树*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 10    <span class="comment">//栈的空间大小   </span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree s[m];<span class="comment">//定义栈</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>; <span class="comment">//栈顶指针</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)  <span class="comment">//遍历左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;m)  <span class="keyword">return</span> ;</span><br><span class="line">            top++;</span><br><span class="line">            s[top]=p;</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top!=<span class="number">0</span>)  <span class="comment">//栈不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s[top];</span><br><span class="line">            top--;</span><br><span class="line">            Visit(p-&gt;data);</span><br><span class="line">            p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>||top!=<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/images/blog_images/Basic_Algorithms/22.jpg" style="zoom:200%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用栈操作的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="comment">/*算法思想：从根结点开始，只要当前结点存在或者栈不空，则循环</span></span><br><span class="line"><span class="comment">1.如果当前结点存在，则进栈并遍历左子树</span></span><br><span class="line"><span class="comment">2.否则退栈并访问，然后遍历右子树*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    BiTree p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;S,p);</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(&amp;S,&amp;p);</span><br><span class="line">            Visit(p-&gt;data);</span><br><span class="line">            p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>先序遍历非递归算法</p>
<img src="/images/blog_images/Basic_Algorithms/23.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre_order</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 思路：当栈不为空或者树的孩子不为空时，循环以下内容：</span></span><br><span class="line"><span class="comment">     * 1.访问当前结点的data值</span></span><br><span class="line"><span class="comment">     * 2.先访问左孩子，如果左孩子存在，则访问data，并将其指针入栈</span></span><br><span class="line"><span class="comment">     * 3.如果孩子不存在，则退栈，并访问右孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Stack S;</span><br><span class="line">    init_stack(&amp;S);</span><br><span class="line">    BiTree p;</span><br><span class="line">    p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!is_empty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visit_node(p);</span><br><span class="line">            push(&amp;S,p);</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pop(&amp;S,&amp;p);</span><br><span class="line">            p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序非递归遍历算法</p>
<img src="/images/blog_images/Basic_Algorithms/24.jpg" style="zoom: 50%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*@brief:从根节点开始，只要当前结点存在，或者栈不空，则循环</span></span><br><span class="line"><span class="comment">*1.从当前结点开始，进栈并遍历左子树，直到左子树为空</span></span><br><span class="line"><span class="comment">*2.如果栈顶结点的右子树为空，或者栈顶结点的右孩子为刚访问过的结点，则退栈并访问，然后将当前结点的指针置为空</span></span><br><span class="line"><span class="comment">*3.否则遍历右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GetTop(Stack *S,BiTree *p);</span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiNode *p,*q;</span><br><span class="line">    Stack S;</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    p=root;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>|| !IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;S,p);</span><br><span class="line">            p=p-&gt;LChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GetTop(&amp;S,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;RChild==<span class="literal">NULL</span>||p-&gt;RChild==q)</span><br><span class="line">            &#123;</span><br><span class="line">                visit(p-&gt;data);</span><br><span class="line">                q=p;</span><br><span class="line">                Pop(&amp;S,&amp;p);</span><br><span class="line">                p=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=p-&gt;RChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="线索二叉树（不考"><a href="#线索二叉树（不考" class="headerlink" title="线索二叉树（不考"></a>线索二叉树（不考</h3><ol>
<li><p>基本概念：充分利用二叉树链表中的空链域，将遍历过程中结点的前驱、后继信息保存下来</p>
<img src="/images/blog_images/Basic_Algorithms/25.png" style="zoom:50%;" />

<ul>
<li>线索：指向前驱、后继结点的指针</li>
<li>线索化：对二叉树一某种次序进行遍历并加上线索的过程</li>
</ul>
</li>
<li><p>二叉树的线索化</p>
<ul>
<li><p>中序线索化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">算法思想：首先创建一个二叉树，然后线索化</span></span><br><span class="line"><span class="comment">1.采用中序递归遍历法遍历算法框架</span></span><br><span class="line"><span class="comment">2.设置有一个指针pre，始终记录刚刚访问过的结点</span></span><br><span class="line"><span class="comment">3.若当前结点的左子域为空，则让左子域指向pre</span></span><br><span class="line"><span class="comment">4.若当前结点的右子域，则让右子域指向当前结点</span></span><br><span class="line"><span class="comment">5.pre=root*/</span></span><br><span class="line">BiTreeNode *pre;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inthread</span><span class="params">(BiTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        Inthread(root-&gt;LChild);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;LChild==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;Ltag=<span class="number">1</span>;</span><br><span class="line">            root-&gt;LChild=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;RChild==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RChild=root;</span><br><span class="line">            pre-&gt;Rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        Inthread(root-&gt;RChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>(中序)线索二叉树中寻找前驱、后继结点</p>
<img src="/images/blog_images/Basic_Algorithms/26.jpg" style="zoom:15%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找前驱结点</span></span><br><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">当 Ltage==1时，即LChild指向前驱</span></span><br><span class="line"><span class="comment">当 Ltage==0时，即LChild指向左孩子，此时，该节点的前驱是，左子树的“最右下端”的结点*/</span></span><br><span class="line">BiTNode *<span class="title function_">InPre</span><span class="params">(BiTNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTNode *pre;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Ltag==<span class="number">1</span>)</span><br><span class="line">        pre=p-&gt;LChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(q=p-&gt;LChild;q-&gt;Rtag==<span class="number">0</span>;q=q-&gt;RChild);</span><br><span class="line">        pre=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找后继结点</span></span><br><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">当Rtag==1时，RChild指向后继；</span></span><br><span class="line"><span class="comment">当Rtag==0时，RChild指向右孩子，此时，该结点的后继是右子树的“最左下端”的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BiTNode *<span class="title function_">InNext</span><span class="params">(BiTNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTNode *next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rtag==<span class="number">1</span>)</span><br><span class="line">        next=p-&gt;RChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(q=p-&gt;RChild;q-&gt;Ltag==<span class="number">0</span>;q=q-&gt;LChild);</span><br><span class="line">        next=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历中序线索树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在中序线索树上求中序遍历的第一个结点</span></span><br><span class="line">BiTNode *<span class="title function_">InFirst</span><span class="params">(BiTree Bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTNode *p=Bt;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;LChild==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;LChild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历中序二叉线索树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TInOnder</span><span class="params">(BiTree Bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    p=InFirst(Bt);</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(p);</span><br><span class="line">        p=InNext(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="树、森林和二叉树的关系"><a href="#树、森林和二叉树的关系" class="headerlink" title="树、森林和二叉树的关系"></a>树、森林和二叉树的关系</h3><ol>
<li><p>树的存储结构</p>
<ul>
<li><p>双亲表示法</p>
<img src="/images/blog_images/Basic_Algorithms/27.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;TNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TNode tree[MAX];</span><br><span class="line">    <span class="type">int</span> nodenum;</span><br><span class="line">&#125;ParentTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>孩子表示法</p>
<img src="/images/blog_images/Basic_Algorithms/28.png" style="zoom:50%;" />

<img src="/images/blog_images/Basic_Algorithms/29.png" style="zoom:50%;" />
</li>
<li><p>孩子兄弟表示法</p>
<img src="/images/blog_images/Basic_Algorithms/30.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    Struct CSNode *FirstChild;<span class="comment">//第一个孩子</span></span><br><span class="line">    Struct CSNode *Nextsibling;<span class="comment">//下一个兄弟</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>树、森林和二叉树的相互转化</p>
<ul>
<li><p>树转化成二叉树（<strong>不考</strong>）</p>
<p>相邻兄弟之间相连，只保留双亲结点与都一个孩子之间的连线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">树转二叉树</span></span><br><span class="line"><span class="comment">使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="comment">//普通树节点的定义如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CHILDREN_NUM 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CSNode</span> *<span class="title">children</span>[<span class="title">MAX_CHILDREN_NUM</span>];</span></span><br><span class="line">&#125;CSNode;</span><br><span class="line"><span class="comment">/*其中，子树的根节点的指针存放在children数组的前k个元素中，</span></span><br><span class="line"><span class="comment">即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，</span></span><br><span class="line"><span class="comment">子树根结点分别保存在children[0]至children[i-1]中。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列相关定义及操作如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">//指向数组内元素的游标</span></span><br><span class="line">    <span class="type">void</span> **<span class="built_in">array</span>;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">create_queue</span><span class="params">()</span>; <span class="comment">//创建队列</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty_queue</span><span class="params">(Queue *tree)</span>; <span class="comment">//队为空返回true,不为空时返回false</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">del_queue</span><span class="params">(Queue *tree)</span>; <span class="comment">//结点指针出队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_queue</span><span class="params">(Queue *tree, <span class="type">void</span> *node)</span>; <span class="comment">//结点指针入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_queue</span><span class="params">(Queue *tree)</span>; <span class="comment">//释放队列</span></span><br><span class="line"><span class="comment">/*transform函数定义如下：</span></span><br><span class="line"><span class="comment">其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点*/</span></span><br><span class="line"></span><br><span class="line">BiTNode* <span class="title function_">transform</span><span class="params">(CSNode *root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Queue *que, *bque;</span><br><span class="line">    </span><br><span class="line">    BiTNode *p;</span><br><span class="line">    <span class="comment">//二叉树根结点创立 </span></span><br><span class="line">    <span class="comment">//小心点, 记得分配空间 </span></span><br><span class="line">    <span class="comment">//为什么想到建立二叉树结点?</span></span><br><span class="line">    <span class="comment">//普通树结点和二叉树结点无法强制类型转换 </span></span><br><span class="line">    p = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    p-&gt;data = root-&gt;data;</span><br><span class="line">    p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">       </span><br><span class="line">    que = create_queue();</span><br><span class="line">    bque = create_queue();</span><br><span class="line">    <span class="comment">//建立双队目的在于建立有序二叉结点序列 </span></span><br><span class="line">    add_queue(que, root);</span><br><span class="line">    add_queue(bque, p);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(!is_empty_queue(que))</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree bq;<span class="comment">//创建二叉树队列头结点(根结点) </span></span><br><span class="line">        bq = del_queue(bque);</span><br><span class="line">        CSNode *q;</span><br><span class="line">        q = del_queue(que);</span><br><span class="line">        <span class="comment">//第一次执行该操作就相当于建立了二叉树的根</span></span><br><span class="line">        <span class="comment">//后来就相当于把最前面的结点提出来（队列是先进先出）    </span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">        BiTNode *former = <span class="literal">NULL</span>;<span class="comment">//former用于记录二叉树的前一个结点</span></span><br><span class="line">        BiTNode *node;<span class="comment">//node用于记录当前结点</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;q-&gt;children[i]!=<span class="literal">NULL</span>; i++)</span><br><span class="line">        &#123; </span><br><span class="line">                node = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">                node-&gt;data = q-&gt;children[i]-&gt;data;</span><br><span class="line">                node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                node-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">        </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="comment">//第一个孩子作为左孩子</span></span><br><span class="line">                    bq-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//其他作为上一个孩子的右孩子</span></span><br><span class="line">                    former-&gt;right = node;</span><br><span class="line">                former= node;</span><br><span class="line"></span><br><span class="line">                add_queue(bque, node);</span><br><span class="line">                add_queue(que, q-&gt;children[i]);            </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(que-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(que);</span><br><span class="line">    <span class="built_in">free</span>(bque-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(bque);   </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>森林转化为二叉树</p>
<p>森林：若干树的集合</p>
<p>向将每棵树转化成相应的二叉树，把后一棵树的根结点作为前一棵树的根结点的右孩子</p>
</li>
<li><p>二叉树还原为树或森林:P186</p>
</li>
</ul>
</li>
<li><p>树与森林的遍历</p>
<ul>
<li><p>树的遍历：以孩子兄弟链表实现树的先根遍历</p>
<p>树的先序遍历顺序相当于转化成的二叉树的中序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RootFirst</span><span class="params">(CSTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        p=root-&gt;FirstChild;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RootFirst(p);</span><br><span class="line">            p=p-&gt;Nextsibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RootFirst</span><span class="params">(CSTree root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;data);</span><br><span class="line">        RootFirst(root-&gt;FirstChild);</span><br><span class="line">        RootFirst(root-&gt;Nextsibling);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>森林的遍历</p>
</li>
</ul>
</li>
</ol>
<h3 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h3><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><ol>
<li><p>哈夫曼树</p>
<p>：由n个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树</p>
<p>基本概念：</p>
<ul>
<li>路径长度：根结点到该结点所经过的分支数目(数线段个数)</li>
<li>权：weight</li>
<li>带权路径长度(PL)：路径长度与权的乘积</li>
<li>树的带权路径长度（WPL）：根到所有<strong>叶子结点</strong>的各个带权路径长度之和</li>
</ul>
</li>
<li><p>构造哈夫曼树：</p>
<p>原则：权值越大的叶结点越靠近根结点，权值越小的叶结点月远离根结点</p>
</li>
<li><p>数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用静态三叉树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20      <span class="comment">//叶子结点的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2*N-1   <span class="comment">//所有结点的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> LChild;</span><br><span class="line">    <span class="type">int</span> RChild;</span><br><span class="line">&#125;HTNode,HufffmanTree[M+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建哈夫曼树<img src="/images/blog_images/Basic_Algorithms/31.png" style="zoom:50%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree ht,<span class="type">int</span> w[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造哈夫曼树ht[M+1],w[n]存放n个权值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ht[i].weight=w[i];</span><br><span class="line">        ht[i].parent=<span class="number">0</span>;</span><br><span class="line">        ht[i].LChild=<span class="number">0</span>;</span><br><span class="line">        ht[i].RChild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        select(ht,i<span class="number">-1</span>,&amp;s1,&amp;s2);<span class="comment">//该函数作用：在h[1]~h[i-1]的范围内选择两个parent为0，且weight最小的结点，其序号分别赋值给s1,s2</span></span><br><span class="line">        </span><br><span class="line">        ht[i].weight=ht[s1].weight+ht[s2].weight;</span><br><span class="line">        ht[s1].parent=i;</span><br><span class="line">        ht[s2].parent=i;</span><br><span class="line">        ht[i].LChild=s1;</span><br><span class="line">        ht[i].RChild=s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHT</span><span class="params">(HTNode ht[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,k,LNode,RNode;</span><br><span class="line">    <span class="type">double</span> min1,min2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)</span><br><span class="line">        ht[i].parent=ht[i].LChild=ht[i].RChild=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)<span class="comment">//构造哈夫曼树的n-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        min1=min2=INFINITE;</span><br><span class="line">        LNode=RNode=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;i<span class="number">-1</span>;k++)<span class="comment">//k&lt;i-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ht[k].parent==<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span>(ht[k].weight&lt;=min1)</span><br><span class="line">                &#123;</span><br><span class="line">                    min2=min1;</span><br><span class="line">                    RNode=INode;</span><br><span class="line">                    min1=ht[k].weight;</span><br><span class="line">                    LNode=k;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ht[k].weight&lt;=min2)</span><br><span class="line">                &#123;</span><br><span class="line">                    min2=ht[i].weight;</span><br><span class="line">                    RNode=k;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ht[i].weight=ht[LNode].weight+ht[RNode].weight;</span><br><span class="line">      ht[i].LChild=LNode;</span><br><span class="line">      ht[i].RChild=RNode;</span><br><span class="line">      ht[LNode].parent=ht[RNode].parent=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：哈夫曼树的特点：</p>
<ul>
<li>n个叶子的哈夫曼树的形态不唯一，但是带权路径长度是相同的</li>
<li>权值越大的结点离根越近</li>
<li>哈夫曼树只有度为0或2的结点，没有度为1的结点</li>
</ul>
</li>
</ol>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><ol>
<li><p>基础概念：</p>
<ul>
<li>编码：将文件字符转化为二进制位串（数据压缩）</li>
<li>前缀编码：采用不等长编码，出现次数多的用短码，且任一编码不能是另一编码的前缀</li>
</ul>
</li>
<li><p>哈夫曼编码</p>
<ul>
<li>以字符出现次数为权值构造一棵哈夫曼树，规定左分支编码为0，右分支编码为1，编码就为：从根到该字符所在的叶子结点的路径上的分支序号构成的序列</li>
<li><img src="/images/blog_images/Basic_Algorithms/32.png" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>哈夫曼编码的算法实现</p>
<ul>
<li><p>算法逻辑：</p>
<img src="/images/blog_images/Basic_Algorithms/33.png" style="zoom:50%;" /></li>
<li><pre><code class="c">/*哈夫曼编码的存储结构*/
#define LEN 100
typedef struct
&#123;
    char ch;  //存放字符
    char code[LEN];//存放编码
&#125;TCode;
TCode CodeBook[LEN];  //编码本
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">/*编码*/</span><br><span class="line">void encoding(HTNode ht[],TCode book[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    char *str=(char*)malloc(n+1);</span><br><span class="line">    str[n]=&#x27;\0&#x27;; //首先存放编码结束符</span><br><span class="line">    int i,j,idx,p;</span><br><span class="line">    //其中，idx指向当前结点，p指向当前结点的parent</span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book[i].ch=ht[i].ch;</span><br><span class="line">        idx=i;</span><br><span class="line">        j=n;//得到的是逆序，所以j倒着计数</span><br><span class="line">        while(p=ht[idx].parent&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ht[p].LChild==idx)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">                str[j]=&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">                str[j]=&#x27;1&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            idx=p;</span><br><span class="line">        &#125;</span><br><span class="line">        strcpy(book[i].code,&amp;str[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*解码*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="第七章：图"><a href="#第七章：图" class="headerlink" title="第七章：图"></a>第七章：图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><ol>
<li>图之间的关系是任意的，多对多的网状数据结构，离散数学的序偶</li>
<li>基本术语<ul>
<li>有向图，无向图，弧</li>
<li>完全图</li>
<li>子图</li>
<li>邻接点</li>
<li>度</li>
<li>权和网：带权的图称为网</li>
<li>路径长度：路径上经过的弧或边的数目；回路或环：第一个顶点和最后一个顶点相同；简单路径：路径中的顶点各不相同</li>
<li>连通图（无向图）：图中任意两个顶点之间都有路径可以连接；强连通图（有向图）</li>
</ul>
</li>
</ol>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ol>
<li><p>邻接矩阵表示法</p>
<p>思想：n个顶点，构建n*n的矩阵。有权图，相连则赋权，反之则为正无穷；无权图：相连则为1，反之则为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20   <span class="comment">//最多顶点个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY  32768    <span class="comment">//表示极大值，无穷</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>DG,DN,UDG,UDN&#125; GraphKind;  <span class="comment">//图的种类，分别为有向图DG，有向网DN，无向图UDG，无向网UDN</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexData;  <span class="comment">//假设顶点数据为字符型,相当于顶点的名字</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjType adj;  <span class="comment">// 无权图：0或1表示是否有连线；有权图：权值或者INFINITY</span></span><br><span class="line">    OtherInfo info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexData vertex[MAX_VERTEX_NUM];  <span class="comment">//顶点向量,也就是顶点的编号</span></span><br><span class="line">    ArcNode arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;  <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">    GraphKind kind;   <span class="comment">//图的种类标志</span></span><br><span class="line">&#125;AdjMatrix;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储空间：可以使用特殊矩阵的压缩存储法，无向图值存储下三角，有向图存储全部</p>
</li>
<li><p>运算</p>
<ul>
<li><p>邻接矩阵表示法创建有向网</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求顶点位置的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVertex</span><span class="params">(AdjMaxtrix *G,VertexData v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>,k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;vexnum;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G-&gt;vertex[k]==v)</span><br><span class="line">        &#123;</span><br><span class="line">            j=k;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateDN</span><span class="params">(AdjMatrix *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,weight;</span><br><span class="line">    VertexData v1,v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;plz enter :vexnum,arcnum&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;vexnum,&amp;G-&gt;arcnum);  <span class="comment">//确定有权网的顶点数混合弧数</span></span><br><span class="line">    <span class="comment">//初始化矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G-&gt;arc[i][j].adj=INFINNTY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化顶点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;G-&gt;vextex[i]);<span class="comment">//输入顶点编号，输入顺序决定了顶点在图中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;arcnum;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;plz enter:顶点，顶点，权值&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c,%c,%d&quot;</span>,&amp;v1,&amp;v2,&amp;weight);<span class="comment">//输入一条弧的两个顶点和一个</span></span><br><span class="line">        i=LocateVertex(G,v1);</span><br><span class="line">        j=LocateVertex(G,v2);</span><br><span class="line">        G-&gt;arc[i][j]=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind=DN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ol>
<li><p>在邻接表当中的每个结点建立一个带头结点的边表，边表中链式存储该结点连接的顶点（无顺序）；表头结点表：所有顶点的序号和头指针组成的单链表</p>
<img src="/images/blog_images/Basic_Algorithms/34.png" style="zoom:40%;" />
</li>
<li><p>存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG,DN,UDG,UDN&#125; GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>  //建立边表结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//顶点在vertex[MAX_VERTEX_NUM]的Index</span></span><br><span class="line">    sruct ArcNode *nextarc;</span><br><span class="line">    OtherInfo info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> //顶点结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexData data;  <span class="comment">//顶点编号</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一个边</span></span><br><span class="line">&#125;VertexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexNode vertex[MAX_VERTEX_NUM];<span class="comment">//顺序表存储顶点</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;AdjList;</span><br></pre></td></tr></table></figure>

<p>注意：对于有向图，想要快捷地获得顶点的度，可以建立逆邻接表</p>
</li>
</ol>
<h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><ol>
<li><p>十字链表的优势是可以直接得出弧数</p>
</li>
<li><p>存储结构<img src="/images/blog_images/Basic_Algorithms/35.png" style="zoom:50%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG,DN,UDG,UDN&#125; GrapKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> //弧结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tailvex,headvex; <span class="comment">//弧头弧尾结点的Index</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">hlink</span>,*<span class="title">tlink</span>;</span><span class="comment">//hlink指向与该弧的弧头相同的下一条弧,同理tlink指向同弧尾</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>//顶点结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexData data;</span><br><span class="line">    ArcNode *firstin,*firstout;</span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexNode vertex[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">    GraphKind kind;</span><br><span class="line">&#125;OrthList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建图的十字链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CrtOrthList</span><span class="params">(OrthList *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">char</span> vt,vh;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;plz enter:vexnum,arcnum&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;vexnum,&amp;G-&gt;arcnum);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;plz enter:VertexData&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;G-&gt;vexnum[i].data);</span><br><span class="line">        G-&gt;vertex[i].firstin=<span class="literal">NULL</span>;</span><br><span class="line">        G-&gt;vertex[i].firstout=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;arcnum;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;plz enter:vertexTail,vertexHead&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c,%c&quot;</span>,&amp;vt,&amp;vh);</span><br><span class="line">        i=LocateVertex(G,vt);</span><br><span class="line">        j=LocateVertex(G,vh);</span><br><span class="line">        p=alloc(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        p-&gt;tailvex=i;</span><br><span class="line">        p-&gt;headver=j;</span><br><span class="line">        p-&gt;tlink=G-&gt;vertex[i].firstout;</span><br><span class="line">        G-&gt;vertex[i].firstout=p;</span><br><span class="line">        p-&gt;hlink=G-&gt;vertex[j].firstin;</span><br><span class="line">        G-&gt;vertex[i].firstin=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="多重链表-不考"><a href="#多重链表-不考" class="headerlink" title="多重链表 (不考)"></a>多重链表 (不考)</h4><p>P222</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>根本思想：在每个顶点处设立一个访问标志，即为图设置一个访问标志数组：visited[n]，用于标志顶点是否被访问过</p>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ol>
<li><p>1）从图中某个顶点v0出发，首先访问v0。</p>
<p>2）依次以v0的未被访问的邻接点为出发点，深度优先搜索图，直至图中所有与v有路径相通的顶点都被访问。</p>
<p>3）n若此时图中还有顶点未被访问，则另选图中一个未被访问的顶点作为起始点，重复上述深度优先搜索过程，直至图中所有顶点均被访问过为止。 </p>
</li>
<li><p>深度优先搜索</p>
<ul>
<li><pre><code class="c">//先遍历图
#define True 1
#define False 0
#define Error -1
#define OK 1
int visited[MAX_VERTEX_NUM];
//对图进行深度优先搜索
void TraverseGraph(Graph g)
&#123;
    int vi;
    for(vi=0;vi&lt;g.vexnum;vi++)
        visited[vi]=0;
    for(vi=0;vi&lt;g.vexnum;vi++)
        if(!visited[vi])
            DepthFirstSearch(g,vi);
&#125;
//深度优先遍历v0所在的联通子图
void DepthFirstSearch(Graph g,int v0)
&#123;
    visit(v0);
    visited[v0]=True;
    w=FirstAdjVertex(g,v0);//获得当前顶点的第一个邻接点的序号
    while(w!=-1)//当邻接点存在
    &#123;
        if(!visited[w])//如果邻接点未被访问
            DepthFirstSearch(g,w);
        w=NextAdjVertex(g,v0,w);//找到下一个邻接点
    &#125;
&#125;
//FirstAdjVertex，NextAdjVertex函数的具体实现由图的存储结构来决定
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- DFS</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  //邻接矩阵表达</span><br><span class="line">  void DepthFirstSearch(AdjMatrix g,int v0)</span><br><span class="line">  &#123;</span><br><span class="line">      visit(v0);</span><br><span class="line">      visited[v0]=True;</span><br><span class="line">      for(vj=0;vj&lt;g.vexnum;vj++)</span><br><span class="line">          if(!visited[vj]&amp;&amp;g.arcs[v0][vj].adj==1)//若邻接点vj未被访问</span><br><span class="line">              DepthFirstSearch(g,vj);</span><br><span class="line">  &#125;</span><br><span class="line">  //邻接表表示</span><br><span class="line">  void DepthFirstSearch(AdjList g,int v0)</span><br><span class="line">  &#123;</span><br><span class="line">      visit(v0);</span><br><span class="line">      visited[v0]=True;</span><br><span class="line">      ArcNode *p;</span><br><span class="line">      p=g.vertex[v0].firstarc;</span><br><span class="line">      while(p!=NULL)</span><br><span class="line">      &#123;</span><br><span class="line">          if(!visited[p-&gt;adjvex])</span><br><span class="line">              DepthFirstSearch(g,p-&gt;adjvex);</span><br><span class="line">          p=p-&gt;nextarc;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>用非递归过程实现深度优先搜索</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS1</span><span class="params">(Graph G,<span class="type">int</span> v0)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    visit(v0);</span><br><span class="line">    visited[v0]=True;</span><br><span class="line">    Push(&amp;S,v0);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(&amp;S,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">        &#123;</span><br><span class="line">            visit(v);</span><br><span class="line">            visited[v]=True;</span><br><span class="line">            w=FirstAdjVertex(g,v);</span><br><span class="line">            <span class="keyword">while</span>(w!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[w])</span><br><span class="line">                    Push(&amp;S,w);</span><br><span class="line">                w=NextAdjVertex(g,v,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>广度优先搜索</p>
<p>类似于树的层次遍历</p>
<img src="/images/blog_images/Basic_Algorithms/36.png" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BreadthFirstSearch</span><span class="params">(Graph g,<span class="type">int</span> v0)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//广度优先搜索图g中v0所在的连通子图</span></span><br><span class="line">    visit(v0);</span><br><span class="line">    visited[v0]=True;<span class="comment">//将该结点标记</span></span><br><span class="line">    InitQueue(&amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    EnterQueue(&amp;Q,v0);<span class="comment">//将v0进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!Empty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteQueue(&amp;Q,&amp;v);<span class="comment">//队头元素v出队</span></span><br><span class="line">        w=FirstAdjVertex(g,v);<span class="comment">//v的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span>(w!=<span class="number">-1</span>)<span class="comment">//全部遍历头元素邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])<span class="comment">//如果该邻接点未被访问过</span></span><br><span class="line">            &#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w]=True;<span class="comment">//访问并标记该邻接点</span></span><br><span class="line">                EnterQueue(&amp;Q,w);<span class="comment">//将该结点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            w=NextAdjVertex(g,v,w);<span class="comment">//求v相对于w的下一个邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h4><ol>
<li><p>深度优先找出从顶点u到v的简单路径</p>
<p>基本思路：设置一个记录搜索线路的数组pre[n],<code>pre[j]=i</code>表示从vi到邻接点vj的边；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pre;</span><br><span class="line"><span class="type">void</span> <span class="title function_">one_path</span><span class="params">(Graph *G,<span class="type">int</span> u,<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    pre=(<span class="type">int</span>*)<span class="built_in">malloc</span>(G-&gt;vexnum*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">        pre[i]=<span class="number">-1</span>;<span class="comment">//初始化，全置于空</span></span><br><span class="line">    pre[u]=<span class="number">-2</span>;<span class="comment">//将pre[u]置为-2，表示初始点u已经被访问了，并且u没有前驱</span></span><br><span class="line">    DFS_path(G,u,v);<span class="comment">//用深度优先搜索找一条从u到v的简单路径</span></span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DFS_path</span><span class="params">(Graph *G,<span class="type">int</span> u,<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=firstadj(G,u);j&gt;=<span class="number">0</span>;j=nextadj(G,u,j))<span class="comment">//遍历u的邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[j]==<span class="number">-1</span>)<span class="comment">//如果该结点没有走过</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre[j]=u;</span><br><span class="line">            <span class="keyword">if</span>(j==v)</span><br><span class="line">            &#123;</span><br><span class="line">                print_path(pre,v);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(DFS_path(G,j,v))<span class="comment">//di&#x27;g</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图的生成树和最小生成树</p>
<ul>
<li><h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h1></li>
<li><p>方法：1.prim算法——加点法；2.算法思想：将所有结点分为已走过U和未走过V-U两个部分，找到连接U和V-U的最小边，不形成回路;3.时间复杂度为O(n^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="type">int</span> lowcost;</span><br><span class="line">&#125;closedge[MAX_VERTEX_NUM];<span class="comment">//该数组用于记录所有与v邻接的、从已走过的结点到v结点的所有边中的最小边的信息；将顶点标记已经走过：将closedge[v].lowcost=0</span></span><br><span class="line"></span><br><span class="line">MiniSpantTree_Prim(AdjMartrix gn,<span class="type">int</span> u)<span class="comment">//从 u顶点出发，按prim算法构造连通网gn的最小生成树，并输出生成树的每条边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//u结点已经走过，现在将它标记：</span></span><br><span class="line">    closedge[u].lowacost=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gn.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=u)<span class="comment">//对V-U中的顶点i，初始化closedge[i]，因为现在U中只有u一i个结点，所以带入u的出度</span></span><br><span class="line">        &#123;</span><br><span class="line">            closedge[i].adjvex=u;</span><br><span class="line">            closedge[i].lowcost=gn.arcs[u][i].adj;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e=<span class="number">1</span>;e&lt;=gn.vexnum<span class="number">-1</span>;e++)</span><br><span class="line">    &#123;</span><br><span class="line">        v=Minium(closedge);<span class="comment">//找到当前最小边（u，v），</span></span><br><span class="line">        u=closedge[v].adjvex;<span class="comment">//u属于U</span></span><br><span class="line">        print(u,v);<span class="comment">//输出函数，输出边</span></span><br><span class="line">        closedge[v].lowcost=<span class="number">0</span>;<span class="comment">//将顶点v纳入U集合</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vexnum;i++)<span class="comment">//在顶点 v并入U之后，更新closedge[i],此操作后续将影响u</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gn.arcs[v][i].adj&lt;closedge[i].lowcost)</span><br><span class="line">            &#123;</span><br><span class="line">                closedge[i].lowcost=gn.arcs[v][i].adj；</span><br><span class="line">                closedge[i].adjvex=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1></li>
<li><p>方法：1.加边法</p>
</li>
<li><pre><code class="c">typedef struct
&#123;
    int no;//顶点编号
    InfoType info;
&#125;VertexType;
typedef struct
&#123;
   int edges[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//邻接矩阵
    int n,e;//顶点数，边数
&#125;

typedef struct &#123;
    int u;//边的起始顶点
    int v;//边的终止顶点
    int w;//边的权值
&#125;Edge;
Edge E[MAX_VERTEX_NUM];//用于存放图中所有的边
void  kruskal(MatGraph g)
&#123;
    int i,j,u1,u2,sn1,sn2,k;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   - # 比较</span><br><span class="line">   </span><br><span class="line">   - prim适用于稠密图，kruskal适用于稀疏图</span><br><span class="line"></span><br><span class="line">#### 有向无环图的应用</span><br><span class="line"></span><br><span class="line">1. 拓扑排序（Topological Sort）</span><br><span class="line"></span><br><span class="line">   - 拓扑序列：G的顶点序列&#123;V1，V2，V3,...,Vn&#125;中，任意两个顶点顶点Vi，Vj，在G中有一条从Vi到Vj的路径，则在序列中Vi必须排列在Vj之前</span><br><span class="line"></span><br><span class="line">   - 拓扑排序：寻找拓扑序列的过程</span><br><span class="line"></span><br><span class="line">   - 拓扑排序：</span><br><span class="line"></span><br><span class="line">     ```c</span><br><span class="line">     //方法：</span><br><span class="line">     //1.在AOV网中选取一个没有前驱结点的顶点V开始遍历</span><br><span class="line">     //2.将此结点和所有以它为起点的边删除</span><br><span class="line">     //3.重复，知道G中不再有没有前驱结点的顶点</span><br><span class="line">     </span><br><span class="line">     //基于邻接表的存储结构，设置一个存放各个顶点的入度的数组indegree[]</span><br><span class="line">     </span><br><span class="line">     typedef struct ANode</span><br><span class="line">     &#123;</span><br><span class="line">         int adjvex;//该边终点的顶点编号</span><br><span class="line">         struct ANode *nextarc;//指向下一条边的指针</span><br><span class="line">     &#125;ArcNode;//边结点</span><br><span class="line">     typedef struct</span><br><span class="line">     &#123;</span><br><span class="line">         Vertex data;//表头结点类型</span><br><span class="line">         int count;//顶点入度数量</span><br><span class="line">         ArcNode *firstarc;//存放顶点的入度</span><br><span class="line">     &#125;VNode;//顶点结点</span><br><span class="line">     typedef struct</span><br><span class="line">     &#123;</span><br><span class="line">         VNode adjlist[MAXV];//邻接表</span><br><span class="line">         int n,e;//结点数n和边数e</span><br><span class="line">     &#125;AdjGraph;  //图</span><br><span class="line">     int TopoSort(AdjGraph *G)</span><br><span class="line">     &#123;</span><br><span class="line">         int i,j;</span><br><span class="line">         int Stack[MAXV],top=-1;</span><br><span class="line">         ArcNode *p;</span><br><span class="line">         for(i=0;i&lt;G-&gt;n;i++)</span><br><span class="line">             G-&gt;adjlist[i].count=0;//将所有结点的入度初始值设置为0</span><br><span class="line">         for(i=-;i&lt;G-&gt;n;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             p=G-&gt;adjlist[i].frstarc;</span><br><span class="line">             while(p!=NULL)&#123;</span><br><span class="line">                 G-&gt;adjlist[p-&gt;adjvex].count++;</span><br><span class="line">                 p=p-&gt;nextarc;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         for(i=0;i&lt;G-&gt;n;i++)</span><br><span class="line">             if(G-&gt;adjlist[i].count==0)//将入度为0的顶点进栈</span><br><span class="line">             &#123;</span><br><span class="line">                 top++;</span><br><span class="line">                 Stack[top]=i</span><br><span class="line">             &#125;</span><br><span class="line">         while(top&gt;-1)</span><br><span class="line">         &#123;</span><br><span class="line">             i=Stack[top];</span><br><span class="line">             top--;</span><br><span class="line">             printf(&quot;%d&quot;,i);</span><br><span class="line">             p=G-&gt;adjlist[i].firstarc;</span><br><span class="line">             while(p!=NULL)&#123;</span><br><span class="line">                 j=p-&gt;adjvex;</span><br><span class="line">                 G-&gt;adjlist[j].count--;</span><br><span class="line">                 if(G-&gt;adjlist[j].count==0)&#123;</span><br><span class="line">                     top++;</span><br><span class="line">                     Stack[top]=j;</span><br><span class="line">                 &#125;</span><br><span class="line">                 p=p-&gt;nextarc;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>关键路径</p>
<ul>
<li><p>AOE网：用顶点表示活动，弧表示活动间的优先关系的有向无环图</p>
</li>
<li><p>源点：存在唯一的、入度为0的顶点；汇点：存在唯一的、出度为0的顶点</p>
</li>
<li><p>关键路径：从源点到汇点 最长路径 的长度即为完成整个工程任务所需要的时间，该路径成为关键场长度</p>
</li>
<li><img src="/images/blog_images/Basic_Algorithms/37.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P245</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CriticalPath</span><span class="params">(adjlist G)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> i,j,k,dut,ei.li;</span><br><span class="line">    <span class="type">char</span> tag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>最短路径</p>
<ul>
<li><p>求某一顶点到其他各个顶点的最短路径</p>
</li>
<li><p><strong>迪杰斯特拉</strong>算法（加点法）：BV1zz4y1m7Nq</p>
</li>
<li><p>该算法按照最短路径长度的递增顺序产生一点到其余各点的所有最短路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MatGraph g,<span class="type">int</span> v)</span><span class="comment">//记住v是起始顶点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dist[MAXV],path[MAXV];<span class="comment">//dist[j]表示源点-&gt;j的最短路径；path[j]表示源点-&gt;j的最短路径中j的前一个顶点</span></span><br><span class="line">    <span class="type">int</span> s[MAXV];<span class="comment">//s用于标记结点是否标记走过</span></span><br><span class="line">    <span class="type">int</span> mindis,u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i]=g.edges[v][i];</span><br><span class="line">        s[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(g,edgds[v][i]&lt;INFINITE)<span class="comment">//当v到i有边时</span></span><br><span class="line">            path[i]=v;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//当不存在边时</span></span><br><span class="line">            path[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v]=<span class="number">1</span>;<span class="comment">//将v放入s中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mindis=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g.n;j++)<span class="comment">//找到下一个最小边的另一个端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="number">0</span>&amp;&amp;dist[j]&lt;mindis)&#123;<span class="comment">//j结点没有走过并且源点到j的路径小于mindis</span></span><br><span class="line">                u=j;<span class="comment">//下一个走的结点是u</span></span><br><span class="line">                mindis=dist[j];<span class="comment">//更新最小路径mindis为dist[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[u]=<span class="number">1</span>;<span class="comment">//将端点u放进已走过的数组</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g.n;j++)<span class="comment">//调整，修改不在s中的顶点的位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(g.edges[u][j]&lt;INF&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j])</span><br><span class="line">                    path[j]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    Dispath(dist,path,g.n,v);<span class="comment">//输出最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求任意一对顶点间的最短路径</p>
</li>
<li><p><strong>弗洛伊德算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组A[i][j]表示对当前顶点i-&gt;j的最短路径长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Floyd</span><span class="params">(MatGraph g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> A[MAXV][MAXV];<span class="comment">//A数组记录任意两点间的最短路径长度</span></span><br><span class="line">    <span class="type">int</span> path[MAXV][MAXV];<span class="comment">//path数组记录Vi-&gt;Vj之间的当前最短路径，实际上只记录了通路上一个结点，不断回溯</span></span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g.n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i][j]=g.edges[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;g.edges[i][j]&lt;INF)<span class="comment">//如果ij邻接</span></span><br><span class="line">                path[i][j]=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g.n;k++)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g.n;j++)</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    A[i][j]=A[i][k]+A[k][j];</span><br><span class="line">                    path[i][j]=path[k][j];<span class="comment">//修改最短路径为经过顶点k</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="第八章：查找"><a href="#第八章：查找" class="headerlink" title="第八章：查找"></a>第八章：查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><ol>
<li>列表：同一类型数据元素的集合</li>
<li>关键字：数据元素某个数据项的值，可以有多个</li>
<li>查找：根据给定的关键字值，找到该数据元素</li>
<li>平均查找长度：</li>
</ol>
<h3 id="查找的基本方法"><a href="#查找的基本方法" class="headerlink" title="查找的基本方法"></a>查找的基本方法</h3><h4 id="基于线性表的查找法"><a href="#基于线性表的查找法" class="headerlink" title="基于线性表的查找法"></a>基于线性表的查找法</h4><ol>
<li><p>顺序查找法（不考）</p>
<ul>
<li><p>数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_SIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    OtherType other_data;</span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RecordType r[LIST_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;RecordList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序查找法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置监视哨，傻逼吧</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqSearch</span><span class="params">(RecordList l,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=l.length;</span><br><span class="line">    l.r[<span class="number">0</span>].key=k;</span><br><span class="line">    <span class="keyword">while</span>(l.r[i].key!=k)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不设置监视哨</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqSearch</span><span class="params">(RecoedList l,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=l.length;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;l.r[i].key!=k)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>折半查找法</p>
<ul>
<li><p>使用条件：1、顺序存储结构；2、按关键字大小有序排列</p>
</li>
<li><p>折半查找法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(RecordList l,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=l.length;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==l.r[mid].key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;l.r[mid].key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分块查找法（略）</p>
</li>
</ol>
<h4 id="基于树的查找法"><a href="#基于树的查找法" class="headerlink" title="基于树的查找法"></a>基于树的查找法</h4><ol>
<li><p>二叉排序树</p>
<ul>
<li><p>定义：左子树上所有结点的值均小于根结点的值；右子树上的所有结点的值均大于根结点</p>
</li>
<li><p>数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">LChild</span>,*<span class="title">RChild</span>;</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入与创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树的递归插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertBST</span><span class="params">(BSTree *bst,KeyType key)</span><span class="comment">//bst是二级指针，下面的(*bst)是一级指针</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree s;</span><br><span class="line">    <span class="keyword">if</span>(*bst==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        s-&gt;key=key;</span><br><span class="line">        s-&gt;LChild=<span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;RChild=<span class="literal">NULL</span>;</span><br><span class="line">        *bst=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;(*bst)-&gt;key)</span><br><span class="line">        InsrtBST(&amp;((*bst)-&gt;LChild),key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;(*bst)-&gt;key)</span><br><span class="line">        InsrtBST(&amp;((*bst)-&gt;RChild),key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBST</span><span class="params">(BSTree *bst)</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    *bst=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    <span class="keyword">while</span>(key!=ENDKEY)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertBST(bst,key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">BSTree <span class="title function_">SearchBST</span><span class="params">(BSTree bst,KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bst==<span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bst-&gt;key==key)  <span class="keyword">return</span> bst;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bst-&gt;key&gt;key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(bst-&gt;LChild,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(bst-&gt;RChild,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line">BSTree <span class="title function_">SearchBST</span><span class="params">(BSTree bst,KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree q;</span><br><span class="line">    q=bst;</span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;key==key) <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;key&gt;key) </span><br><span class="line">            q=q-&gt;LChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q=q-&gt;RChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的删除</p>
<p><img src="/images/blog_images/Basic_Algorithms/38.jpg" style="zoom:20%;" /><img src="/images/blog_images/Basic_Algorithms/39.jpg" style="zoom:19%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">DelBST</span><span class="params">(BSTree t,KeyType k)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *p,*f,*s,*q;<span class="comment">//p是要删除的结点，f是p的双亲结点，s是p结点在中序遍历中的直接前驱，q是s的双亲结点，S就是p的左子树的最右结点</span></span><br><span class="line">    p=t;</span><br><span class="line">    f=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//找到p结点，定位f结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key==k)  <span class="keyword">break</span>;</span><br><span class="line">        f=p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key&gt;k)   p=p-&gt;LChild;</span><br><span class="line">        <span class="keyword">else</span>  p=p-&gt;RChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  <span class="keyword">return</span> t;<span class="comment">//若找不到，返回原来的二叉排序树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;LChild==<span class="literal">NULL</span>)<span class="comment">//如果p没有左子树，直接将p的右子树连到f上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="literal">NULL</span>)  <span class="comment">//如果p是根结点</span></span><br><span class="line">            t=p-&gt;RChild;<span class="comment">//直接将树根指向p的右孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;LChild==p)<span class="comment">//如果p是f的左孩子</span></span><br><span class="line">            f-&gt;LChild=p-&gt;RChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果p是f的右孩子</span></span><br><span class="line">            f-&gt;RChild=p-&gt;RChild;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//p有左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=p;<span class="comment">//提示：q是s的双亲结点</span></span><br><span class="line">        s=p-&gt;LChild;</span><br><span class="line">        <span class="comment">//找到p的中序前驱结点s，即p的左子树的最右下结点，因此s没有右孩子</span></span><br><span class="line">        <span class="keyword">while</span>(s-&gt;RChild)</span><br><span class="line">        &#123;</span><br><span class="line">            q=s;<span class="comment">//q是s的双亲结点</span></span><br><span class="line">            s=s-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为s没有右孩子，所以只用考虑左子树</span></span><br><span class="line">        <span class="keyword">if</span>(q==p)<span class="comment">//如果p是s的双亲结点，s是p的左孩子</span></span><br><span class="line">            q-&gt;LChild=s-&gt;LChild;<span class="comment">//将原s的左子树接到q的左孩子</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            q-&gt;RChild=s-&gt;LChild;<span class="comment">//将原s的左子树接到q的右孩子</span></span><br><span class="line">        p-&gt;key=s-&gt;key;</span><br><span class="line">        <span class="built_in">free</span>(s);<span class="comment">//删除s结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>平衡二叉排序树</p>
<ul>
<li><p>定义：1.左右子树的高度之差的绝对值小于1（1、0、-1）；2.左右子树也是平衡二叉排序树</p>
</li>
<li><p>平衡因子：该结点的左右子树的高度之差</p>
</li>
<li><p>平衡二叉树的调整：一般下层的祖先结点先恢复平衡，将使上层的祖先结点恢复平衡，因此应该调整最下面的失衡子树</p>
</li>
<li><p>LL型</p>
<img src="/images/blog_images/Basic_Algorithms/40.jpg" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LL型：在左子树的左子树插入结点导致失衡</span></span><br><span class="line"><span class="comment">//失衡特点：A-&gt;bf==2,B-&gt;bf==1</span></span><br><span class="line"><span class="comment">//方法：将B的右孩子改为A的左孩子，将A改为B的右孩子</span></span><br><span class="line">A-&gt;LChild=B-&gt;RChild;</span><br><span class="line">B-&gt;RChild=A;</span><br><span class="line">A-&gt;bf=<span class="number">0</span>;</span><br><span class="line">B-&gt;bf=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//设A原来的双亲结点为FA，将B接到FA</span></span><br><span class="line"><span class="keyword">if</span>(FA==<span class="literal">NULL</span>)<span class="comment">//若A为根结点</span></span><br><span class="line">    t=B;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A==FA-&gt;LChild)</span><br><span class="line">    FA-&gt;LChild=B;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A==FA-&gt;RChild)</span><br><span class="line">    FA-&gt;RChild=B;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LR型</p>
<img src="/images/blog_images/Basic_Algorithms/41.jpg" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//失衡点的左子树的右子树插入结点导致失衡</span></span><br><span class="line"><span class="comment">//失衡特点：A-&gt;bf==2,B-&gt;bf==-1</span></span><br><span class="line"><span class="comment">//方法：将C的右孩子改为A的左孩子，将A改为C的右孩子，将C的左孩子改成B的右孩子，将B改成C的左子树</span></span><br><span class="line">B-&gt;RChild=C-&gt;LChild;</span><br><span class="line">A-&gt;LChild=C-&gt;RChild;</span><br><span class="line">C-&gt;Lchild=B;</span><br><span class="line">C-&gt;RChild=A;</span><br><span class="line"><span class="comment">//修改平衡因子</span></span><br><span class="line"><span class="keyword">if</span>(S-&gt;key&lt;C-&gt;key)<span class="comment">//如果S是插在C的左子树</span></span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;bf=<span class="number">-1</span>;B-&gt;bf=<span class="number">0</span>;C-&gt;bf=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;key&lt;C-&gt;key)<span class="comment">//如果S是插在C的右子树</span></span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;bf=<span class="number">0</span>;B-&gt;bf=<span class="number">1</span>;C-&gt;bf=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;key=C-&gt;key)<span class="comment">//如果C结点本身就是插入的新结点S，即原来B的右子树为空，Cl、Cr、Bl、Ar均为空</span></span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;bf=<span class="number">0</span>；B-&gt;bf=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改根结点,FA是A的双亲结点，t指向根结点</span></span><br><span class="line"><span class="keyword">if</span>(FA=<span class="literal">NULL</span>)  t=C;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A==FA-&gt;LChild)  FA-&gt;LChild=C;</span><br><span class="line"><span class="keyword">else</span> FA-&gt;RChild=C;</span><br></pre></td></tr></table></figure>

</li>
<li><p>RR型</p>
<img src="/images/blog_images/Basic_Algorithms/42.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A的右子树的右子树插入结点导致失衡</span></span><br><span class="line"><span class="comment">//RR型的失衡特点是：A-&gt;bf=-2,B-&gt;bf=-1;</span></span><br><span class="line"><span class="comment">//方法：将B的左子树改成A的右子树，将A改成B的左子树</span></span><br><span class="line">A-&gt;RChild=B-&gt;LChild;</span><br><span class="line">B-&gt;LChild=A;</span><br><span class="line"><span class="comment">//修改平衡因子</span></span><br><span class="line">A-&gt;bf=<span class="number">0</span>;</span><br><span class="line">B-&gt;bf=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//修改根指针</span></span><br><span class="line"><span class="keyword">if</span>(FA=<span class="literal">NULL</span>)  t=B;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A==FA-&gt;LChild)  FA-&gt;LChild=B;</span><br><span class="line"><span class="keyword">else</span> FA-&gt;RChild=B;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RL型</p>
<img src="/images/blog_images/Basic_Algorithms/43.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A的右子树的左子树插入新结点S</span></span><br><span class="line"><span class="comment">//与LR型对称,失衡特点：A-&gt;bf==-2,B-&gt;bf==1</span></span><br><span class="line"><span class="comment">//方法：将C的左子树改成A的右子树，将C的右子树改成B的左子树，将A改成C的左子树，将B改成C的右子树</span></span><br><span class="line">A-&gt;RChild=C-&gt;LChild;</span><br><span class="line">B-&gt;LChild=C-&gt;RChild;</span><br><span class="line">C-&gt;RChild=A;</span><br><span class="line">C-&gt;RChild=B;</span><br><span class="line"><span class="comment">//修改平衡因子</span></span><br><span class="line"><span class="keyword">if</span>(S-&gt;key&lt;C-&gt;key)<span class="comment">//如果S插入C的左子树</span></span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;bf=<span class="number">0</span>;B-&gt;bf=<span class="number">-1</span>;C-&gt;bf=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;key&gt;C-&gt;key)<span class="comment">//如果S插入C的右子树</span></span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;bf=<span class="number">1</span>;B-&gt;bf=<span class="number">0</span>;C-&gt;bf=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S-&gt;key=C-&gt;key)<span class="comment">//如果插入的S结点就是C结点，即B的左右子树为空，A的左子树为空</span></span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;bf=<span class="number">0</span>;B-&gt;bf=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改根指针</span></span><br><span class="line"><span class="keyword">if</span>(FA=<span class="literal">NULL</span>)  t=C;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A==FA-&gt;LChild)  FA-&gt;LChild=C;</span><br><span class="line"><span class="keyword">else</span> FA-&gt;RChild=C;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整插入代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法思想：</span></span><br><span class="line"><span class="comment">//1.寻找插入位置，并且找到失衡结点A</span></span><br><span class="line"><span class="comment">//2.插入结点S</span></span><br><span class="line"><span class="comment">//3.确定结点B,B是</span></span><br><span class="line"><span class="comment">//4.修改从B到S路径上的个结点的平衡因子</span></span><br><span class="line"><span class="comment">//5.根据前面的四种方法，来调整失衡树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="type">int</span> bf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">RChild</span>,*<span class="title">LChild</span>;</span>   </span><br><span class="line">&#125;ALVTNode,*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ins_AVLTree</span><span class="params">(AVLTree *avlt,KeyType K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建新结点S</span></span><br><span class="line">    AVLTNode *S,*A,*FA,*p,*fp;</span><br><span class="line">    S=(AVLTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AvlTNode));</span><br><span class="line">    S-&gt;key=k;</span><br><span class="line">    S-&gt;LChild=S-&gt;RChild=<span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;bf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(*avlt==<span class="literal">NULL</span>)  *avlt=S;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//首先找到S的插入位置，同时记录距离S的插入位置最近且平衡因子不为0的结点A，A 可能 是失衡结点</span></span><br><span class="line">        A=*avlt;FA=<span class="literal">NULL</span>;</span><br><span class="line">        p=*avlt;fp==<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//寻找p的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;bf!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                A=p;FA=fp;</span><br><span class="line">            &#125;</span><br><span class="line">            fp=p;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;p-&gt;key)  p=p-&gt;LChild;</span><br><span class="line">            <span class="keyword">else</span> p=p-&gt;RChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时p=NULL</span></span><br><span class="line">        <span class="comment">//插入S</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;fp-&gt;key)    fp-&gt;LChild=S;</span><br><span class="line">        <span class="keyword">else</span>   fp-&gt;RChild=S;</span><br><span class="line">        <span class="comment">//确定结点B（B一般是A的S所在子树的祖先节点），并修改A的平衡因子</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;A-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            B=A-&gt;LChild;A-&gt;bf+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            B=A-&gt;RChild;A-&gt;bf-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改B到S的路径上各结点的平衡因子（原值均为0）</span></span><br><span class="line">        p=B;</span><br><span class="line">        <span class="keyword">while</span>(p!=S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;p-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;bf=<span class="number">1</span>;p=p-&gt;LChild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;bf=<span class="number">-1</span>;p=p-&gt;RChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断失衡类型并做相应处理</span></span><br><span class="line">        <span class="keyword">if</span>(A-&gt;bf==<span class="number">2</span>&amp;&amp;B-&gt;bf=<span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">/*LL型*/</span>&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A-&gt;bf==<span class="number">2</span>&amp;&amp;B-&gt;bf=<span class="number">-1</span>)</span><br><span class="line">        &#123;<span class="comment">/*LR型*/</span>&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A-&gt;bf=<span class="number">-2</span>&amp;&amp;B-&gt;bf==<span class="number">-1</span>)</span><br><span class="line">        &#123;<span class="comment">/*RR型*/</span>&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A-&gt;bf==<span class="number">-2</span>&amp;&amp;B-&gt;bf==<span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">/*RL型*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="计算式查找法——哈希法"><a href="#计算式查找法——哈希法" class="headerlink" title="计算式查找法——哈希法"></a>计算式查找法——哈希法</h3><p>基本思想：在元素关键词k和元素的存储位置p之间建立一种函数关系</p>
<p>冲突问题：k1≠k2,但是 H(k1)&#x3D;H(k2),则称k1和k2 同义</p>
<h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><ol>
<li><p>直接地址法</p>
<p>关键词的某个线性函数作为哈希地址：Hash(key)&#x3D;a*key+b</p>
</li>
<li><p>数字分析法</p>
<ul>
<li>构造方法：在关键词比较长且形式已知的情况下，选取随机性好的若干位作为哈希地址</li>
</ul>
</li>
<li><p>平方取中法</p>
<ul>
<li>构造方法：取关键词平方值的中间几位作为哈希地址</li>
<li>Hash(key)&#x3D;”key的平方的中间几位”</li>
<li>扩大差别，贡献均匀；适用于不知道全部关键词的情况</li>
</ul>
</li>
<li><p>分段叠加法</p>
<ul>
<li>构造方法：将关键词按照哈希表地址位数（eg:哈希表长度为1000，则三位一段），分成位数相等的几部分（不足的舍去）；然后将这几部分叠加和作为哈希地址</li>
<li>移位法：直接相加</li>
<li>折叠法：隔一个数就把一个数倒过来相加P301</li>
</ul>
</li>
<li><p>除留余数法</p>
<ul>
<li>构造方法：Hash(key)&#x3D;key %p,p&lt;&#x3D;m(通常选择一个不大于m的素数)</li>
</ul>
</li>
<li><p>伪随机数法</p>
<ul>
<li>构造方法：Hash(key)&#x3D;random(key)</li>
</ul>
</li>
</ol>
<h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><ol>
<li><p>开放定址法</p>
<ul>
<li><p>当出现冲突的时候,以冲突的地址为关键词寻找下一个哈希地址</p>
</li>
<li><p>线性探测法<img src="/images/blog_images/Basic_Algorithms/44.png" style="zoom:50%;" /></p>
</li>
<li><p>平方探查法</p>
<img src="/images/blog_images/Basic_Algorithms/45.png" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>双散列法（再哈希法）</p>
<ul>
<li>Hi&#x3D;RHi(key),i&#x3D;1,2,3,…,k</li>
<li>不容易产生聚集，但是增加了计算时间</li>
</ul>
</li>
<li><p>连地址法</p>
<ul>
<li>基本思想L：将所有哈希地址为i 的元素构成一个单链表中（称为同义词链），并将单链表的头指针存储在哈希表的的第i个单元中</li>
<li><img src="/images/blog_images/Basic_Algorithms/46.png" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>*哈希算法的性能分析</p>
</li>
</ol>
<ul>
<li>装填因子：a&#x3D;表中填入的记录数&#x2F;哈希表的长度</li>
<li><img src="/images/blog_images/Basic_Algorithms/47.png" style="zoom:50%;" /></li>
</ul>
<h4 id="哈希表的查找过程"><a href="#哈希表的查找过程" class="headerlink" title="哈希表的查找过程"></a>哈希表的查找过程</h4><img src="/images/blog_images/Basic_Algorithms/48.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> m 100  <span class="comment">//哈希表的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY  100<span class="comment">//代表空记录的关键词值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> RecordType HashTable[m];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">HashSearch</span><span class="params">(HashType ht,KryTypr k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h0=Hash(k);</span><br><span class="line">    <span class="keyword">if</span>(ht[h0].key==NULLKEY)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ht[h0].key==k)  <span class="keyword">return</span> h0;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hi=(h0+i)%m;</span><br><span class="line">            <span class="keyword">if</span>(ht[hi].key==NULLKEY)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ht[hi].key==k)   <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   *哈希算法的性能分析</p>
<ol>
<li>装填因子：a&#x3D;表中填入的记录数&#x2F;哈希表的长度</li>
<li><img src="/images/blog_images/Basic_Algorithms/49.png" style="zoom:50%;" /></li>
</ol>
<h2 id="第九章：排序"><a href="#第九章：排序" class="headerlink" title="第九章：排序"></a>第九章：排序</h2><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><ol>
<li>稳定排序和不稳定排序：关键词的领先关系在排序前后是否发生改变</li>
</ol>
<h3 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h3><p>给定某个数列，将它排序插入</p>
<h4 id="直接插入排序（略）"><a href="#直接插入排序（略）" class="headerlink" title="直接插入排序（略）"></a>直接插入排序（略）</h4><p>类似于数组的排序,按照关键词排序的规则找到插入位置后，将后面的元素都向移动一位</p>
<p>时间复杂度：O(n^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置监视哨r[0],作用是1.防止越界；2.暂存需插入的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsSort</span><span class="params">(RecordType r[],<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=length;i++)<span class="comment">//从i=2开始，因为第一个数据自动看成一个有序子数列</span></span><br><span class="line">    &#123;</span><br><span class="line">        r[<span class="number">0</span>]=r[i];<span class="comment">//将待插入的数据放入监视哨r[0]中</span></span><br><span class="line">        j=i<span class="number">-1</span>;<span class="comment">//j指向已经排号的有序数列的最后一位</span></span><br><span class="line">        <span class="keyword">while</span>(r[<span class="number">0</span>].key&lt;r[j].key)<span class="comment">//寻找插入位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            r[j+<span class="number">1</span>]=r[j];</span><br><span class="line">            j=j<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r[j+<span class="number">1</span>]=r[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="折半插入排序法"><a href="#折半插入排序法" class="headerlink" title="折半插入排序法"></a>折半插入排序法</h4><p>时间复杂度：O(n^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinSort</span><span class="params">(RecordType r[],<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> x;<span class="comment">//插入数据</span></span><br><span class="line">    <span class="type">int</span> low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=r[i];</span><br><span class="line">        low=<span class="number">1</span>;</span><br><span class="line">        high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)<span class="comment">//寻找插入位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x.key&lt;r[mid].key)</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=low;--j)<span class="comment">//将插入位置以后的元素后移</span></span><br><span class="line">            r[j+<span class="number">1</span>]=r[j];</span><br><span class="line">        r[low]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ol>
<li>适用范围：关键词序列基本有序且个数较少</li>
<li>方法：将待排序的关键词分为若干个较小的子序列，对子序列进行直接插入排序</li>
<li>时间复杂度：O(n^1.5)</li>
<li><img src="/images/blog_images/Basic_Algorithms/50.png" style="zoom:50%;" /></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellInsert</span><span class="params">(RecordType r[],<span class="type">int</span> length;<span class="type">int</span> delta)</span><span class="comment">//delta是增量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>+delta;i&lt;length;i++)</span><br><span class="line">        <span class="keyword">if</span>(r[i].key&lt;r[i-delta].key)</span><br><span class="line">        &#123;</span><br><span class="line">            r[<span class="number">0</span>]=r[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-delta;j&gt;<span class="number">0</span>&amp;&amp;r[<span class="number">0</span>].key&lt;r[j].key;j-=delta)</span><br><span class="line">                r[j+delta]=r[j];</span><br><span class="line">            r[delta+j]=r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(RecordType r[],<span class="type">int</span> length;<span class="type">int</span> delta[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ShellInsert(r,length,delta[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交换类排序法"><a href="#交换类排序法" class="headerlink" title="交换类排序法"></a>交换类排序法</h3><h4 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,x;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i;j++)</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-2</span>;i&gt;=j;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                x=a[i];</span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">                a[i+<span class="number">1</span>]=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,x;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    j=n<span class="number">-2</span>;<span class="comment">//j是本遍扫描的终点下标，初始值为n-2</span></span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                x=a[i];</span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">                a[i+<span class="number">1</span>]=x;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>思路P329,时间复杂度：O(n^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QkSort</span><span class="params">(RecordType r[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        pos=QKPass(r,low,high);</span><br><span class="line">        QKSort(r,low,pos<span class="number">-1</span>);</span><br><span class="line">        QKSort(r,pos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">QKPass</span><span class="params">(RecordType r[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=r[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;r[high].key&gt;=x.key)</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            r[low]=r[high];</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;r[low].key&lt;x.key)</span><br><span class="line">            low++;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            r[high]=r[low];</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[low]=x;</span><br><span class="line">    <span class="keyword">return</span>  low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择类排序法"><a href="#选择类排序法" class="headerlink" title="选择类排序法"></a>选择类排序法</h3><h4 id="简单选择排序法（略）"><a href="#简单选择排序法（略）" class="headerlink" title="简单选择排序法（略）"></a>简单选择排序法（略）</h4><p>比较次数为n(n-1)&#x2F;2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(RecordType r[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//从i以后的无需序列中选出关键词最小的记录k</span></span><br><span class="line">            <span class="keyword">if</span>(r[j].key&lt;r[k].key)</span><br><span class="line">                k=j;</span><br><span class="line">        <span class="keyword">if</span>(k!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            x=r[i];</span><br><span class="line">            r[i]=r[k];</span><br><span class="line">            r[k]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树形选择排序（不考）"><a href="#树形选择排序（不考）" class="headerlink" title="树形选择排序（不考）"></a>树形选择排序（不考）</h4><p>又称锦标赛排序，即两两比较</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ol>
<li><p>定义：排序过程中将向量中存储的数据看成一颗完全二叉树，任意结点r[i]的左孩子是r[2i]，右孩子是r[2i+1]</p>
</li>
<li><p>堆定义：完全二叉树满足条件：<code>r[i].key&gt;=r[2i].key&amp;&amp;r[i].key&gt;=r[2i+1].key</code>——大根堆</p>
<p><code>r[i].key&lt;=r[2i].key&amp;&amp;r[i].key&lt;=r[2i+1].key</code>——小根堆</p>
</li>
<li><p>重建堆</p>
<p>将根顶记录改变后，从上到下调整堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sift</span><span class="params">(RecordType r[],<span class="type">int</span> k,<span class="type">int</span> m)</span><span class="comment">//设，r[k.m]是以r[k]为根的完全二叉树，大根堆,m是堆中最后一个记录</span></span><br><span class="line">&#123;</span><br><span class="line">    r[<span class="number">0</span>]=r[k];<span class="comment">//暂存根记录</span></span><br><span class="line">    j=<span class="number">2</span>*k;<span class="comment">//j指向根结点的左孩子</span></span><br><span class="line">    finished=FALSE;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=m&amp;&amp;!finished)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m&amp;&amp;r[j].key&lt;r[j+<span class="number">1</span>].key)<span class="comment">//左孩子大于右孩子</span></span><br><span class="line">            j++;<span class="comment">//即，选出最大的孩子去和根结点比较</span></span><br><span class="line">        <span class="keyword">if</span>(r[<span class="number">0</span>].key&gt;=r[j].key)</span><br><span class="line">            finished=TRUE;<span class="comment">//结束筛选</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r[k]=r[j];</span><br><span class="line">            k=j;</span><br><span class="line">            j=<span class="number">2</span>*k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[k]=r[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建初堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">crt_heap</span><span class="params">(RecordType r[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)<span class="comment">//自最后一个非叶结点：位置为【n/2】进行筛选建堆</span></span><br><span class="line">        sift(r,i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆排序的算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(RecordType r[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    crt_heap(r,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r[<span class="number">0</span>]=r[<span class="number">1</span>];</span><br><span class="line">        r[<span class="number">1</span>]=r[i];</span><br><span class="line">        r[i]=r[<span class="number">0</span>];<span class="comment">//将堆顶记录和堆中最后一个记录互换</span></span><br><span class="line">        sift(r,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="归并排序法"><a href="#归并排序法" class="headerlink" title="归并排序法"></a>归并排序法</h3><ol>
<li><p>基本思想：将两个或者两个以上的有序表合并成一个新的有序表</p>
</li>
<li><p>空间复杂度</p>
</li>
<li><pre><code class="c">void Merge(RecordType r1[],int low,int mid,int high,RecordType r[])//已知r1[low..mid]和r1[mid+1..high]分别按关键词有序排列，将它们合成存放在r2[low..high]中
&#123;
    int i,j,k;
    i=low;
    j=mid+1;
    k=low;
    while(i&lt;=mid&amp;&amp;j&lt;=high)&#123;
        if(r1[i].key&lt;=r1[j].key)&#123;
            r[k]=r1[i];
            i++;
        &#125;else&#123;
            r[k]=r1[j];
            j++;
        &#125;
        k++;
    &#125;
    while(i&lt;=mid)&#123;
        r[k]=r1[i];
        k++;
        i++;
    &#125;
    while(j&lt;=high)&#123;
        r[k]=r1[j];
        k++;
        j++;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">void MergeSort(RecordType r1[],int low,int high,RecordType r[])</span><br><span class="line">&#123;</span><br><span class="line">    RecordType *r2;</span><br><span class="line">    r2=(RecordType*)malloc(sizeof(RecordType)*(high-low+1));</span><br><span class="line">    if(low==high)</span><br><span class="line">        r[low]=r1[low];</span><br><span class="line">    else&#123;</span><br><span class="line">        mid=(low+high)/2;</span><br><span class="line">        MergeSort(r1,low,mid,r2);</span><br><span class="line">        MergeSort(r1,mid+1,high,r2);</span><br><span class="line">        Merge(r2,low,mid,high,r);</span><br><span class="line">    &#125;</span><br><span class="line">    free(r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="分配类排序"><a href="#分配类排序" class="headerlink" title="分配类排序"></a>分配类排序</h3><h4 id="多关键字排序-不考"><a href="#多关键字排序-不考" class="headerlink" title="多关键字排序(不考)"></a>多关键字排序(不考)</h4><ol>
<li><img src="/images/blog_images/Basic_Algorithms/51.png" style="zoom:50%;" /></li>
<li><img src="/images/blog_images/Basic_Algorithms/52.png" style="zoom:50%;" /></li>
</ol>
<h4 id="链式基数排序"><a href="#链式基数排序" class="headerlink" title="链式基数排序"></a>链式基数排序</h4><ol>
<li><img src="/images/blog_images/Basic_Algorithms/53.png" style="zoom:50%;" />	
</li>
<li><pre><code class="c">#define RADIX 10//元素个数
#define KEY_SIZE 6
#define LIST_SIZE 20
typedef int KeyType;
typedef struct
&#123;
    KeyType keys[KEY_SIZE];//子关键字数组
    OtherType other_data;
    int next;
&#125;RecordType;
typedef struct
&#123;
    RecordType r[LIST_SIZE+1];//r[0]为头结点
    int length;
    int keynum;
&#125;SLinkList;
typedef int PVector[RADIX];
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 链式基数排序算法</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void Distribute(RecordType r[],int i,PVector f,PVector e)</span><br><span class="line">   /*本算法按照第i位的关键字key[i]建立RADIX个队列，同一个队列中记录的key[i]相同，f[j]和e[j]分别指向队列中的第一个和最后一个，f[j]=0表示是空队列*/</span><br><span class="line">   &#123;</span><br><span class="line">       int j;</span><br><span class="line">       for(j=0;j&lt;=RADIX-1;j++)</span><br><span class="line">           f[i]=0;</span><br><span class="line">       int p=r[0].next;//p指向链表中的第一个记录</span><br><span class="line">       while(p!=0)</span><br><span class="line">       &#123;</span><br><span class="line">           j=Order(r[p].key[i]);</span><br><span class="line">           if(f[j]==0) </span><br><span class="line">               f[j]=p;</span><br><span class="line">           else</span><br><span class="line">               r[e[j]].next=p;</span><br><span class="line">           e[j]=p;</span><br><span class="line">           p=r[p].next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void Collect(RecordType r[],PVector f,PVector e)</span><br><span class="line">   &#123;</span><br><span class="line">       int j=0;</span><br><span class="line">       while(f[j]==0) j++;//找到第一个非空队列</span><br><span class="line">       r[0].next=f[j];</span><br><span class="line">       t=e[j];</span><br><span class="line">       while(j&lt;RADIX-1)</span><br><span class="line">       &#123;</span><br><span class="line">           j++;</span><br><span class="line">           while((j&lt;RADIX-1)&amp;&amp;(f[j]==0))   j++;//找下一个非空队列；</span><br><span class="line">           if(f[j]!=0)</span><br><span class="line">           &#123;</span><br><span class="line">               r[t].next=f[j];</span><br><span class="line">               t=e[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       r[t].next=0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void RadixSort(RecordType r[],int n,int d)</span><br><span class="line">   &#123;</span><br><span class="line">       int</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/09/24/Vancouver/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
                © Zhang Qianyu | 
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
